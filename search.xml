<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[有关Lucene的一些东西]]></title>
      <url>%2F2017%2F04%2F11%2F%E6%9C%89%E5%85%B3Lucene%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%2F</url>
      <content type="text"><![CDATA[因为项目中用到了Lucene,这里简单的说一下关于Lucene的一些东西. 大概介绍Lucene 是一个基于 Java 的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta 家族中的一个开源项目。也是较为流行的基于 Java 开源全文检索工具包。图 1 表示了搜索应用程序和 Lucene 之间的关系，也反映了利用 Lucene 构建搜索应用程序的流程：图 1. 搜索应用程序和 Lucene 之间的关系 索引举个例子,索引有点类似目录,就是什么内容,会告诉你在第几页，这样就能帮助读者比较快地找到相关内容的页码。而数据库索引能够大大提高查询的速度原理也是一样，通过目录查找的速度要比一页一页地翻内容高多少倍……当然他还有另外一个原因是它是排好序的。对于检索系统来说核心是一个排序问题。而数据库索引不是为全文索引设计的，因此，使用like数据库索引不是为全文索引设计的，因此，使用like “%keyword%”时，数据库索引是不起作用的，在使用like查询时，搜索过程又变成类似于一页页翻书的遍历过程了，所以对于含有模糊查询的数据库服务来说，LIKE对性能的危害是极大的。如果是需要对多个关键词进行模糊匹配：like”%keyword1%” and like “%keyword2%” …其效率也就可想而知了。 所以建立一个高效检索系统的关键是建立一个类似于科技索引一样的反向索引机制，将数据源（比如多篇文章）排序顺序存储的同时，有另外一个排好序的关键词列表，用于存储关键词==&gt;文章映射关系，利用这样的映射关系索引：[关键词==&gt;出现关键词的文章编号，出现次数（甚至包括位置：起始偏移量，结束偏移量），出现频率]，检索过程就是把模糊查询变成多个可以利用索引的精确查询的逻辑组合的过程。从而大大提高了多关键词查询的效率，所以，全文检索问题归结到最后是一个排序问题。 由此可以看出模糊查询相对数据库的精确查询是一个非常不确定的问题，这也是大部分数据库对全文检索支持有限的原因。Lucene最核心的特征是通过特殊的索引结构实现了传统数据库不擅长的全文索引机制，并提供了扩展接口，以方便针对不同应用的定制。 lucene的一些包org.apache.lucene.document: 存储结构这个包提供了一些为封装要索引的文档所需要的类，比如 Document, Field。这样，每一个文档最终被封装成了一个 Document 对象。org.apache.lucene.analysis: 语言分析器这个包主要功能是对文档进行分词，因为文档在建立索引之前必须要进行分词，所以这个包的作用可以看成是为建立索引做准备工作。org.apache.lucene.index: 索引入口这个包提供了一些类来协助创建索引以及对创建好的索引进行更新。这里面有两个基础的类：IndexWriter 和 IndexReader，其中 IndexWriter 是用来创建索引并添加文档到索引中的，IndexReader 是用来删除索引中的文档的。org.apache.lucene.search: 搜索入口这个包提供了对在建立好的索引上进行搜索所需要的类。比如 IndexSearcher 和 Hits, IndexSearcher 定义了在指定的索引上进行搜索的方法，Hits 用来保存搜索得到的结果。org.apache.Lucene.queryParser: 查询分析器org.apache.Lucene.store: 底层IO/存储结构org.apache.Lucene.util: 一些公用的数据结构… 建立索引为了对文档进行索引，Lucene 提供了五个基础的类，他们分别是 Document, Field, IndexWriter, Analyzer, Directory。下面我们分别介绍一下这五个类的用途：DocumentDocument 是用来描述文档的，这里的文档可以指一个 HTML 页面，一封电子邮件，或者是一个文本文件。一个 Document 对象由多个 Field 对象组成的。可以把一个 Document 对象想象成数据库中的一个记录，而每个 Field 对象就是记录的一个字段。FieldField 对象是用来描述一个文档的某个属性的，比如一封电子邮件的标题和内容可以用两个 Field 对象分别描述。Analyzer在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是由 Analyzer 来做的。Analyzer 类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter 来建立索引。IndexWriterIndexWriter 是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document 对象加到索引中来。Directory这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是 FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是 RAMDirectory，它表示一个存储在内存当中的索引的位置。熟悉了建立索引所需要的这些类后，我们就开始对某个目录下面的文本文件建立索引了，清单 1 给出了对某个目录下的文本文件建立索引的源代码。 搜索文档利用 Lucene 进行搜索就像建立索引一样也是非常方便的。在上面一部分中，我们已经为一个目录下的文本文档建立好了索引，现在我们就要在这个索引上进行搜索以找到包含某个关键词或短语的文档。Lucene 提供了几个基础的类来完成这个过程，它们分别是呢 IndexSearcher, Term, Query, TermQuery, Hits. 下面我们分别介绍这几个类的功能。Query这是一个抽象类，他有多个实现，比如 TermQuery, BooleanQuery, PrefixQuery. 这个类的目的是把用户输入的查询字符串封装成 Lucene 能够识别的 Query。TermTerm 是搜索的基本单位，一个 Term 对象有两个 String 类型的域组成。生成一个 Term 对象可以有如下一条语句来完成：Term term = new Term(“fieldName”,”queryWord”); 其中第一个参数代表了要在文档的哪一个 Field 上进行查找，第二个参数代表了要查询的关键词。TermQueryTermQuery 是抽象类 Query 的一个子类，它同时也是 Lucene 支持的最为基本的一个查询类。生成一个 TermQuery 对象由如下语句完成： TermQuery termQuery = new TermQuery(new Term(“fieldName”,”queryWord”)); 它的构造函数只接受一个参数，那就是一个 Term 对象。IndexSearcherIndexSearcher 是用来在建立好的索引上进行搜索的。它只能以只读的方式打开一个索引，所以可以有多个 IndexSearcher 的实例在一个索引上进行操作。TopDocsTopDocs 是用来保存搜索的结果的。 项目使用总结现在的项目是这样使用Lucene的:import jar-&gt;用job初始化待查询数据(建立索引)-&gt;查询返回(搜索文档),因为Lucene有很简单的api,这里就不细说了,结尾附上大致的代码例子: 一个例子创建索引:12345678910111213141516171819202122232425/** * 处理百科信息 */public void procAllForTermBaike() throws Exception &#123; List&lt;Map&lt;String, String&gt;&gt; baikeList = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); Query&lt;TermBaike&gt; query = this.createQuery(); long counts = this.count(query); Integer pages = this.luceneService.getPages(Integer.valueOf(String.valueOf(counts))); for (int i = 1; i &lt;= pages; i++) &#123; // 查询获取数据 query.offset((i - 1) * 100).limit(100); QueryResults&lt;TermBaike&gt; result = this.find(query); List&lt;TermBaike&gt; TermBaikeList = result.asList(); // 封装返回数据 for (TermBaike termBaike : TermBaikeList) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("id", termBaike.get_id()); map.put("name", termBaike.getVcName()); map.put("nameEn", termBaike.getVcNameEn()); map.put("label", String.valueOf(ServiceTypeEnum.BAIKE_LAB.getValue())); baikeList.add(map); &#125; &#125; this.luceneService.createIndex(ServiceTypeEnum.BAIKE.getKey(), baikeList, Boolean.TRUE);&#125; …job相关的代码就不放上来了,就是用job跑这个procxxx方法 调用的方法: 123456789101112/** * 获取页数 */public Integer getPages(Integer totalNum) throws Exception &#123; Integer pages = 1; if ((totalNum % 100) == 0) &#123; pages = totalNum / 100; &#125; else &#123; pages = (totalNum / 100) + 1; &#125; return pages;&#125; 123456789101112131415161718192021222324/** * 创建索引 */public void createIndex(Integer serviceType, List&lt;Map&lt;String, String&gt;&gt; list, Boolean isDel) throws Exception &#123; IndexWriter indexWriter = this.initIndexWriter(serviceType, isDel); try &#123; for (Map&lt;String, String&gt; map : list) &#123; Document doc = new Document(); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; if (null != entry.getKey() &amp;&amp; null != entry.getValue()) &#123; doc.add(new TextField(entry.getKey(), entry.getValue(), Field.Store.YES)); &#125; &#125; indexWriter.addDocument(doc); &#125; &#125; catch (Exception e) &#123; logger.error(e); e.printStackTrace(); &#125; finally &#123; if (null != indexWriter) &#123; indexWriter.close(); &#125; &#125;&#125; 搜索文档:12345678910111213141516171819202122/** * 百科信息查询 * * @param key 关键字 * @param currentPage 页码 * @return * @throws Exception */public List&lt;TermBaikeVo&gt; queryBaike(String key, Integer currentPage) throws Exception &#123; List&lt;TermBaikeVo&gt; termBaikeVoList = new ArrayList&lt;TermBaikeVo&gt;(); Sort sort = new Sort(new SortField("name", SortField.Type.STRING, true)); List&lt;Document&gt; docList = this.luceneService.query(ServiceTypeEnum.BAIKE.getKey(), key, "name", sort, currentPage, DEF_ENUM.DEF_TWENTY.getnCode()); for (Document doc : docList) &#123; TermBaikeVo termBaikeVo = new TermBaikeVo(); termBaikeVo.setBaikeId(doc.get("id")); termBaikeVo.setVcName(doc.get("name")); termBaikeVo.setVcName(doc.get("nameEn")); termBaikeVo.setVcLabel(doc.get("label")); termBaikeVoList.add(termBaikeVo); &#125; return termBaikeVoList;&#125; 调用的方法: 1234567891011121314151617181920212223242526272829303132/*** 单条件分页查询*/public List&lt;Document&gt; query(Integer serviceType, String key, String field, Sort sort, Integer currentPage, Integer pageSize) throws Exception &#123; List&lt;Document&gt; docList = new ArrayList&lt;Document&gt;(); IndexReader reader = this.initIndexReader(serviceType); try &#123; Analyzer analyzer = new StandardAnalyzer(); IndexSearcher indexSearcher = new IndexSearcher(reader); QueryParser parser = new QueryParser(field, analyzer); org.apache.lucene.search.Query query = parser.createPhraseQuery(field, key); TopDocs topDocs = indexSearcher.search(query, currentPage + pageSize, sort); ScoreDoc[] scoreDocs = topDocs.scoreDocs; if (scoreDocs.length == 0) &#123; scoreDocs = this.wildcardQuery(key, field, indexSearcher); &#125; int begin = pageSize * (currentPage - 1); int end = Math.min(begin + pageSize, scoreDocs.length); for (int i = begin; i &lt; end; i++) &#123; int docID = scoreDocs[i].doc; Document doc = indexSearcher.doc(docID); docList.add(doc); &#125; &#125; catch (Exception e) &#123; logger.error(e); &#125; finally &#123; if (null != reader) &#123; reader.close(); &#125; &#125; return docList;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编码散记]]></title>
      <url>%2F2017%2F04%2F01%2F%E7%BC%96%E7%A0%81%E6%95%A3%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[开发习惯 guava,程序员的好朋友. controller层, 不要放有关业务的代码.业务代码放service层. 如果if(){}else if(){}…..&gt;=3 个if, 个人觉得,用switch case 比较好. 有些功能尽量使用java官方工具类.不要自己写,比如StringUtils,CollectionUtils,Arrays等. 合理规范注释, 前人编码注释清晰了, 后人改动思路就明了了.还有就是命名的规范(代码改动,更新注释). 尽量不要写重复代码,多次使用的代码抽出来独立成为一个方法调用,private或public根据具体业务情况而定. 生产代码禁止以System及Throwable.printStackTrace的方式输出日志信息, 必须用Logger替代, 注意log等级. controller层是前台和后台交互的.接口单一职责.一个接口一个功能(如果是在controller层进行权限控制的话,能更好的进行权限控制), 尽量清晰.不过service层可以提高代码复用率. 一些技巧 运用set的key不能重复, 可以去重. 有坑的点 开发中还是特别要注意new object的这个问题. 要注意map是无序的,千万不要数据库排序查询出来结果之后,放map. BigDecimal.add,subtract,multiply,divide,返回的是一个new object,要注意. get/set,方法中最好别写逻辑,报错console不会提示,只能自己一步步debug进去看异常. 注意Integer(-128~127)值的==和equals比较,(-XX:AutoBoxCacheMax这个参数可以了解下) 性能相关 利用好缓存, 缓存最常用最适合的地方:数据字典. for循环内避免查询处理相同的数据, 多次使用的数据放for循环外面. 关于工具 chrome开发者工具: 点击代码窗口左下角的那个’{ }’(pretty print) 标签, 能格式化被minify掉的css/js. chrome开发者工具: 可以设置网络的访问速度来模拟一个网络很慢的情况.(network-&gt;no throtting-&gt;随意设置).]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[念奴娇 桂花]]></title>
      <url>%2F2017%2F04%2F01%2F%E5%BF%B5%E5%A5%B4%E5%A8%87-%E6%A1%82%E8%8A%B1%2F</url>
      <content type="text"><![CDATA[芳影绰约，寒玉阶，蟾宫折桂婵娟。辗转花前，愁几句，落华曾为谁妍？知愁草木，韶白深切，哭对情海如烟。枉占三秋，十里西风瘦却。 小镇塘前客栈，纵几缕相思，几多诗篇。风捡残花，相思染，几度诗冷窗前。鬓白几许？乃红尘点缀，桂香自怜。凌云分付，风花雪月云烟。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[夜行者的伤]]></title>
      <url>%2F2017%2F04%2F01%2F%E5%A4%9C%E8%A1%8C%E8%80%85%E7%9A%84%E4%BC%A4%2F</url>
      <content type="text"><![CDATA[你充满阳光我怕见到你有太阳就会有影子而我是个夜行者我不怕黑夜一个人连影子都别跟着我我不怕孤独一个人去浪迹天涯我不怕无助一个人躲在被窝里哭我也不会求助我不怕我无牵无挂]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原本两个人]]></title>
      <url>%2F2017%2F04%2F01%2F%E5%8E%9F%E6%9C%AC%E4%B8%A4%E4%B8%AA%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[以前一个人是享受躺在床上看着天花板数着星星可它并不透明我却看到整个星空一个人的世界一个人的梦后来一个人是罪无可恕躺在草地上望着夜空却再也见不到星星但这可是天空我也不是很懂一个人的牢笼一个人的痛]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下项目环境搭建部署]]></title>
      <url>%2F2017%2F03%2F29%2Flinux%E4%B8%8B%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[centos7安装 不做展示,自行解决 数据库安装: 1yum install mariadb mariadb-server 启动mariadb服务程序并添加到开机启动项中： 12[root@linuxprobe ~]# systemctl start mariadb[root@linuxprobe ~]# systemctl enable mariadb 为了保证数据库的安全性，一定要进行初始化工作： 第1步：设定root用户密码。第2步：删除匿名帐号。第3步：禁止root用户从远程登陆。第4步：删除test数据库并取消对其的访问权限。第5步：刷新授权表，让初始化后的设定立即生效。 1234567891011121314151617[root@linuxprobe ~]# mysql_secure_installationEnter current password for root (enter for none): 当前数据库密码为空，直接敲击回车。Set root password? [Y/n] yNew password: 输入要为root用户设置的数据库密码。Re-enter new password: 重复再输入一次密码。Password updated successfully!Remove anonymous users? [Y/n] y（删除匿名帐号） ... Success!Disallow root login remotely? [Y/n] y(禁止root用户从远程登陆) ... Success!Remove test database and access to it? [Y/n] y(删除test数据库并取消对其的访问权限) - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reload privilege tables now? [Y/n] y(刷新授权表，让初始化后的设定立即生效) ... Success! 设置防火墙对数据库服务的允许策略： 1234[root@linuxprobe ~]# firewall-cmd --permanent --add-service=mysqlsuccess[root@linuxprobe ~]# firewall-cmd --reloadsuccess 使用root用户登陆到数据库中： 123[root@linuxprobe ~]# mysql -u root -pEnter password: 此处输入root用户在数据库中的密码。Welcome to the MariaDB monitor. Commands end with ; or \g. 创建一个新的数据库用户： 创建数据库用户的命令:CREATE USER 用户名@主机名 IDENTIFIED BY ‘密码’; 12MariaDB [(none)]&gt; create user &apos;herakles&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;Query OK, 0 rows affected (0.00 sec) ‘%’允许远程登陆此用户 给予herakles用户对user表单的查询、更新、删除、插入权限：12MariaDB [mysql]&gt; GRANT SELECT,UPDATE,DELETE,INSERT on mysql.user to luke@localhost;Query OK, 0 rows affected (0.00 sec) redis 安装必要包 1yum install gcc 安装redis 123456#下载wget http://download.redis.io/releases/redis-3.0.0.tar.gztar zxvf redis-3.0.0.tar.gzcd redis-3.0.0#如果不加参数,linux下会报错make MALLOC=libc 启动 12345#启动redissrc/redis-server &amp;(/home/chenwulou/redis-3.2.4/src/redis-server /home/chenwulou/redis-3.2.4/redis.conf &amp;&gt;/dev/null &amp;)#关闭redissrc/redis-cli shutdown 测试 123456$ src/redis-cli127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; get foo&quot;bar&quot;$ MongoDB 1yum install -y mongodb-org 12345678910mongodb服务使用#启动service mongod start#停止service mongod stop#重启service mongod restart#增加开机启动chkconfig mongod on 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用工具]]></title>
      <url>%2F2017%2F03%2F28%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[远程连接服务器: winscp/putty/Xshell ftp: Xftp mongodbGUI: Robomongo 编辑器: notepad++, vim 接口调试: postman 监控分析: BTrace]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux日常记录]]></title>
      <url>%2F2017%2F03%2F27%2FLinux%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[linux开机启动服务目录:/etc/init.d 启动redis客户端:/usr/local/redis-3.2.4/src/redis-cli Linux下剪切拷贝命令 命令格式: mv source dest mv: 命令字 source: 源文件 dest: 目的地址 Linux下拷贝命令 命令格式：cp [-rf] source dest 使用备注：源文件在前，目标文件在后。 参数说明： -r 若 source 中含有目录，则将目录下之档案亦皆依序拷贝至目的地。-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。 删除命令 1、删除home目录下的test目录 rm /home/test 2、这种不带参数的删除方法经常会提示无法删除，因为权限不够。 rm -r /home/test 3、-r是递归的删除参数表中的目录及其子目录。 目录将被清空并且删除。 当删除目录包含的具有写保护的文件时用户通常是被提示的。 rm -rf /home/test -4、f是不提示用户，删除目录下的所有文件。请注意检查路径，输成别的目录就悲剧了。 rm -ir /home/test 5、-i是交互模式。使用这个选项，rm命令在删除任何文件前提示用户确认。 Yum软件仓库 命令 作用 yum r…epolist all 列出所有仓库。 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 yum remove 软件包 移除软件包 yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 systemctl管理服务的启动、重启、停止、重载、查看状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 service foo start systemctl start foo.service 启动服务 service foo restart systemctl restart foo.service 重启服务 service foo stop systemctl stop foo.service 停止服务 service foo reload systemctl reload foo.service 重新加载配置文件（不终止服务） service foo status systemctl status foo.service 查看服务状态 systemctl设置服务的开机启动、不启动、查看各级别下服务启动状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 chkconfig foo on systemctl enable foo.service 开机自动启动 chkconfig foo off systemctl disable foo.service 开机不自动启动 chkconfig foo systemctl is-enabled foo.service 查看特定服务是否为开机自启动 chkconfig –list systemctl list-unit-files –type=service 查看各个级别下服务的启动与禁用情况]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb操作日志]]></title>
      <url>%2F2017%2F03%2F27%2Fmongodb%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223// 根据查询结果,替换某个字段的字符串// 模糊查询vcPicUrl中有'http:'字段的结果var list = db.getCollection('tbArticle').find(&#123;"vcPicUrl":/http:/&#125;);// var index = 0;// list.toArray();// while(list.hasNext())&#123;// var url = list[index].vcPicUrl;// print(url);// var rurl = url.replace('http:','https:');// print(rurl);// db.getCollection('tbArticle').update(&#123;"_id":list[index]._id&#125;, &#123;$set:&#123;'vcPicUrl':rurl&#125;&#125;);// index=index+1;// &#125;print(list.length());// 将vcPicUrl中的http: 替换成 https: for (var i = 0; i &lt; list.length(); i++) &#123; var article = list[i]; var url = article.vcPicUrl; var rurl = url.replace('http:','https:'); db.getCollection('tbArticle').update(&#123;"_id":article._id&#125;, &#123;$set:&#123;'vcPicUrl':rurl&#125;&#125;); &#125; print("success")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring data jpa 查询使用案例]]></title>
      <url>%2F2017%2F03%2F27%2Fspring-data-jpa-%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031/** * */public String getSumAmount(final AcctDtlSearchDto searchDto, final ERecvPayFlag recvPayFlag) &#123; String startDate = searchDto.getStartDate(); String endDate = searchDto.getEndDate(); EUseType useType = searchDto.getUseType(); CriteriaBuilder builder = em.getCriteriaBuilder(); CriteriaQuery&lt;BigDecimal&gt; query = builder.createQuery(BigDecimal.class); Root&lt;SubAcctTrxJnlPo&gt; root = query.from(SubAcctTrxJnlPo.class); Predicate predicate = builder.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); Expression&lt;BigDecimal&gt; sumTrxAmt = builder.sum(root.&lt;BigDecimal&gt; get("trxAmt")); if (StringUtils.isNotBlank(startDate)) &#123; expressions.add(builder.greaterThanOrEqualTo(root.&lt;String&gt; get("trxDate"), startDate)); &#125; if (StringUtils.isNotBlank(endDate)) &#123; expressions.add(builder.lessThanOrEqualTo(root.&lt;String&gt; get("trxDate"), endDate)); &#125; if (EUseType.ALL != useType) &#123; expressions.add(builder.equal(root.&lt;EUseType&gt; get("useType"), useType)); &#125; if (null != recvPayFlag) &#123; expressions.add(builder.equal(root.&lt;ERecvPayFlag&gt; get("recvPayFlag"), recvPayFlag)); &#125; query.where(predicate); query.select(sumTrxAmt); BigDecimal result = em.createQuery(query).getSingleResult(); result = (null == result ? BigDecimal.ZERO : result); return result.toString(); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469/** * */private BigDecimal getWarrantedProjectAmt(final String userId) &#123; List&lt;ProjectPo&gt; list = projectRepository.findAll(new Specification&lt;ProjectPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ProjectPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.equal(root.&lt;String&gt; get("wrtrId"), userId)); List&lt;EProjStatus&gt; inStatus = Arrays.asList(EProjStatus.RISK_AUDIT, EProjStatus.RISK_RATING); expressions.add(root.&lt;EProjStatus&gt; get("status").in(inStatus)); return predicate; &#125; &#125;); BigDecimal warrantAmt = BigDecimal.ZERO; for (ProjectPo proj : list) &#123; warrantAmt = warrantAmt.add(proj.getProjectAmt()); &#125; return warrantAmt;&#125;/** * */public List&lt;ProdServItemDto&gt; getItems(final ProdServItemSearchDto searchDto, final String currUserId)&#123; long times = System.currentTimeMillis(); List&lt;ProdServInfoPo&gt; list = prodServInfoRepo.findAll(new Specification&lt;ProdServInfoPo&gt;()&#123; @Override public Predicate toPredicate(Root&lt;ProdServInfoPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); String workDate = CommonBusinessUtil.getCurrentWorkDate(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); // 已授信过滤 expressions.add(cb.exists(getProdServParamSubQuery(query, cb, workDate, root.&lt;String&gt;get("userId")))); if(StringUtils.isNotBlank(searchDto.getName()))&#123; expressions.add(cb.like(root.&lt;EnterpriseInfoPo&gt;get("enterpriseInfoPo").&lt;String&gt;get("name"), "%"+searchDto.getName()+"%")); &#125; if(StringUtils.isNotBlank(searchDto.getTelephone()))&#123; expressions.add(cb.like(root.&lt;EnterpriseInfoPo&gt;get("enterpriseInfoPo").&lt;String&gt;get("telephone"), "%"+searchDto.getTelephone()+"%")); &#125; Expression&lt;Boolean&gt; servProvTypes = root.&lt;EWarrantProdServProvType&gt; get("servProvType").in(EWarrantProdServProvType.MICRO_CMPY, EWarrantProdServProvType.WRTR_CMPY); Expression&lt;Boolean&gt; unionServProvType = cb.and( cb.equal(root.&lt;EWarrantProdServProvType&gt; get("servProvType"), EWarrantProdServProvType.UNION_CMPY), cb.exists(getSubQuery(query, cb, currUserId, root.&lt;String&gt; get("userId")))); expressions.add(cb.or(servProvTypes, unionServProvType)); /** 如果是小贷,不显示自己 **/ expressions.add(cb.notEqual(root.&lt;String&gt;get("userId"), currUserId)); return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String fncrId, Path&lt;String&gt; prodServUserId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;ProdServInfoPo&gt; prodServ = subQuery.from(ProdServInfoPo.class); Join&lt;ProdServInfoPo, ProdServGroupPo&gt; prodServGroup = prodServ.join("prodServGroupList", JoinType.INNER); Join&lt;ProdServGroupPo, GroupPo&gt; group = prodServGroup.join("groupPo", JoinType.INNER); Join&lt;GroupPo, GroupUserPo&gt; groupUser = group.join("groupUserPoSet", JoinType.INNER); Join&lt;GroupUserPo, FncrInfoPo&gt; fncrInfo = groupUser.join("fncrInfoPo", JoinType.INNER); return subQuery.select(prodServ.&lt;String&gt;get("userId")).where( cb.and(cb.equal(prodServ.get("userId"), prodServUserId), cb.equal(fncrInfo.&lt;String&gt; get("userId"), fncrId))); &#125; private Subquery&lt;String&gt; getProdServParamSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String workDate, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;ProdServParamPo&gt; param = subQuery.from(ProdServParamPo.class); return subQuery.select(param.&lt;String&gt;get("userId")).where( cb.and(cb.equal(param.get("userId"), userId), cb.lessThanOrEqualTo(param.&lt;String&gt;get("startDate"), workDate), cb.greaterThanOrEqualTo(param.&lt;String&gt;get("endDate"), workDate) )); &#125; &#125;); List&lt;ProdServItemDto&gt; items = new ArrayList&lt;ProdServItemDto&gt;(); for(ProdServInfoPo serv: list)&#123; EnterpriseInfoPo ent = serv.getEnterpriseInfoPo(); ProdServItemDto item = new ProdServItemDto(); item.setUserId(serv.getUserId()); item.setWrtrKind(serv.getWrtrKind()); item.setServProvType(serv.getServProvType()); item.setQq(ent.getQq()); item.setName(ent.getName()); item.setAddress(ent.getAddress()); item.setZipCode(ent.getZipCode()); item.setContractName(ent.getContractName()); item.setTelephone(ent.getTelephone()); item.setWrtrFileId(serv.getWrtrFileId()); items.add(item); &#125; logger.debug("cost times is &#123;&#125; ms", (System.currentTimeMillis()-times)); return items; &#125; //expressions.add(cb.greaterThanOrEqualTo(root.&lt;Date&gt; get("createTs"), DateUtils.getStartDate(DateUtils.getDate(fromDate, YYYY_MM_DD))));//expressions.add(cb.lessThanOrEqualTo(root.&lt;Date&gt; get("createTs"), DateUtils.getEndDate(DateUtils.getDate(toDate, YYYY_MM_DD))));/***公告查询,这里主要看根据roleIds 不同用户显示不同的公告*/public DataTablesResponseDto&lt;ArticleDto&gt; getArticlesForHome(final ArticleSearchDto searchCriteria) &#123;Pageable pageable = PaginationUtil.buildPageable(searchCriteria, PersistenceUtil.getIdName(ArticlePo.class));Specification&lt;ArticlePo&gt; specification = new Specification&lt;ArticlePo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ArticlePo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); if (null != searchCriteria) &#123; String nowDateStr = DateUtils.formatDate(new Date(), ApplicationConsts.DATE_FORMAT); EArticleStatus status = searchCriteria.getStatus(); EColumnCategory categoryId = searchCriteria.getCategoryId(); List&lt;Predicate&gt; predicateList = new ArrayList&lt;Predicate&gt;(); List&lt;UserRolePo&gt; userRolePoList = userRoleRepository.findByUserId(securityContext .getCurrentUserId()); for (UserRolePo userRole : userRolePoList) &#123; predicateList.add(cb.like(root.&lt;String&gt; get("roleIds"), "%" + userRole.getRoleId() + "%")); &#125; predicateList.add(cb.isNull(root.&lt;String&gt; get("roleIds"))); Predicate[] predicate1 = new Predicate[predicateList.size()]; Predicate predicate2 = cb.or(predicateList.toArray(predicate1)); expressions.add(predicate2); expressions.add(cb.lessThanOrEqualTo(root.&lt;String&gt; get("startDt"), nowDateStr)); expressions.add(cb.greaterThanOrEqualTo(root.&lt;String&gt; get("endDt"), nowDateStr)); if (EArticleStatus.ALL != status &amp;&amp; null != status) &#123; expressions.add(cb.equal(root.&lt;EArticleStatus&gt; get("status"), status)); &#125; if (EColumnCategory.ALL != categoryId &amp;&amp; null != categoryId) &#123; expressions.add(cb.equal(root.&lt;EColumnCategory&gt; get("categoryId"), categoryId)); &#125; &#125; return predicate; &#125;&#125;;Page&lt;ArticlePo&gt; articlePos = articleRepository.findAll(specification, pageable);DataTablesResponseDto&lt;ArticleDto&gt; result = PaginationUtil.populateFromPage(articlePos, new Function&lt;ArticlePo, ArticleDto&gt;() &#123; @Override public ArticleDto apply(ArticlePo po) &#123; ArticleDto articleDto = ConverterService.convert(po, ArticleDto.class); return articleDto; &#125; &#125;);return result;&#125;/** * */public BigDecimal getSumInvstAmt(String acctNo, String productId)&#123; CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;BigDecimal&gt; query = cb.createQuery(BigDecimal.class); Root&lt;ProductSubscribeDtlPo&gt; root = query.from(ProductSubscribeDtlPo.class); Expression&lt;BigDecimal&gt; subsAmtCm = cb.prod(root.&lt;BigDecimal&gt;get("unitAmt"), root.&lt;Long&gt;get("unit").as(BigDecimal.class)); Expression&lt;BigDecimal&gt; sumSubAmtQuery = cb.sum(subsAmtCm); Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); if(StringUtils.isNotBlank(acctNo))&#123; expressions.add(cb.equal(root.&lt;String&gt;get("acctNo"), acctNo)); &#125; if(StringUtils.isNotBlank(productId))&#123; expressions.add(cb.equal(root.&lt;String&gt;get("productId"), productId)); &#125; query.select(sumSubAmtQuery); query.where(predicate); BigDecimal result = em.createQuery(query).getSingleResult(); return result==null?BigDecimal.ZERO:result;&#125;/** * */private List&lt;ProjectPo&gt; getProjectByFncrId(final String fncrAcctNo) &#123; List&lt;ProjectPo&gt; list = projectRepository.findAll(new Specification&lt;ProjectPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ProjectPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.equal(root.&lt;String&gt; get("fncrAcctNo"), fncrAcctNo)); List&lt;EProjStatus&gt; inStatus = Arrays.asList(EProjStatus.INIT, EProjStatus.WRTR_AUDIT, EProjStatus.RISK_AUDIT, EProjStatus.RISK_RATING, EProjStatus.PASSED); expressions.add(root.&lt;EProjStatus&gt; get("status").in(inStatus)); return predicate; &#125; &#125;); return list;&#125;/** * */@Transactional(readOnly = true)public List&lt;SimpleMemberDto&gt; searchFncrMembers(final String keyWord) &#123; Sort sort = new Sort(Direction.ASC, PersistenceUtil.getIdName(AcctPo.class)); Pageable pageable = new PageRequest(0, 20, sort); Page&lt;AcctPo&gt; page = acctRepository.findAll(new Specification&lt;AcctPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;AcctPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.exists(getSubQuery(query, cb, root.&lt;String&gt;get("userId")))); String keyWordTrim = keyWord.trim(); if (StringUtils.isNotBlank(keyWord)) &#123; expressions.add(cb.or( cb.like(root.&lt;String&gt; get("acctNo"), "%" + keyWordTrim + "%"), cb.or(cb.like(root.&lt;UserPo&gt; get("userPo").&lt;String&gt; get("sname"), "%" + keyWordTrim + "%"), cb.like(root.&lt;UserPo&gt; get("userPo").&lt;String&gt; get("mobile"), "%" + keyWordTrim + "%")))); &#125; else &#123; expressions.add(cb.equal(root.&lt;String&gt; get("acctNo"), "0")); &#125; return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;SimpleUserPo&gt; suser = subQuery.from(SimpleUserPo.class); Join&lt;SimpleUserPo, FncrInfoPo&gt; fncrInfo = suser.join("fncrInfoPo", JoinType.INNER); return subQuery.select(suser.&lt;String&gt;get("userId")).where( cb.and(cb.equal(suser.get("userId"), userId), cb.equal(suser.get("userId"), fncrInfo.&lt;String&gt; get("userId")))); &#125; &#125;, pageable); List&lt;SimpleMemberDto&gt; items = new ArrayList&lt;SimpleMemberDto&gt;(); List&lt;AcctPo&gt; list = page.getContent(); for (AcctPo acct : list) &#123; SimpleMemberDto dto = new SimpleMemberDto(); UserPo userPo = acct.getUserPo(); StringBuilder label = new StringBuilder(); String sname = userPo.getSname(); String mobile = userPo.getMobile(); mobile = null == mobile ? "":mobile; String acctNo = acct.getAcctNo(); dto.setAcctNo(acctNo); dto.setSname(sname); dto.setMobile(mobile); label.append("姓名:"); label.append(sname); label.append(",手机号:"); label.append(mobile); label.append(",交易账号:"); label.append(acctNo); dto.setLabel(label.toString()); items.add(dto); &#125; return items;&#125;/** * */public List&lt;GroupUserInfoDto&gt; getInvsUsers(final GroupUserSearchDto searchDto) &#123; Specification&lt;UserPo&gt; spec = new Specification&lt;UserPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;UserPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.not(cb.exists(getSubQuery(query, cb, searchDto.getGroupId(), root.&lt;String&gt; get("userId"))))); if(searchDto!=null)&#123; if(StringUtils.isNotBlank(searchDto.getKeyWord()))&#123; expressions.add(cb.or( cb.like(root.&lt;String&gt;get("sname"), "%"+searchDto.getKeyWord()+"%"), cb.like(root.&lt;String&gt;get("nickName"), "%"+searchDto.getKeyWord()+"%"), cb.like(root.&lt;String&gt;get("mobile"), "%"+searchDto.getKeyWord()+"%"), cb.exists(getWorkUnitSubQuery(query, cb, searchDto.getKeyWord(), root.&lt;String&gt; get("userId"))) )); &#125; else&#123; // 未传关键字查询条件，则查询结果为空 expressions.add(cb.equal(root.&lt;String&gt;get("userId"),"0")); &#125; &#125; return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String groupId, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;GroupUserPo&gt; groupUsers = subQuery.from(GroupUserPo.class); return subQuery.select(groupUsers.&lt;String&gt;get("userId")).where( cb.and(cb.equal(groupUsers.&lt;String&gt; get("groupId"), groupId)), cb.equal(groupUsers.&lt;String&gt; get("userId"), userId)); &#125; private Subquery&lt;String&gt; getWorkUnitSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String keyWord, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;PersonalInfoPo&gt; personalInfo = subQuery.from(PersonalInfoPo.class); return subQuery.select(personalInfo.&lt;String&gt;get("userId")).where( cb.equal(personalInfo.&lt;String&gt; get("userId"), userId), cb.like(personalInfo.&lt;String&gt; get("workUnit"), "%"+searchDto.getKeyWord()+"%")); &#125; &#125;; List&lt;UserPo&gt; userList = userRepository.findAll(spec); List&lt;GroupUserInfoDto&gt; dtoList = new ArrayList&lt;GroupUserInfoDto&gt;(); for(UserPo ur:userList)&#123; GroupUserInfoDto dto = new GroupUserInfoDto(); dto.setName(ur.getSname()); dto.setNickName(ur.getNickName()); dto.setUserType(ur.getUserType()); dto.setUserId(ur.getUserId()); if(ur.getUserType() == EUserType.PERSON)&#123; PersonalInfoPo persnoalInfo = personalInfoRepository.findOne(ur.getUserId()); if(persnoalInfo!=null)&#123; dto.setWorkUnit(persnoalInfo.getWorkUnit()); &#125; &#125; else&#123; dto.setWorkUnit(null); &#125; dtoList.add(dto); &#125; return dtoList;&#125; /** * json */private Specification&lt;Qfjbxxdz&gt; getWhereClause(final JSONArray condetion,final JSONArray search) &#123; return new Specification&lt;Qfjbxxdz&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Qfjbxxdz&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; List&lt;Predicate&gt; predicate = new ArrayList&lt;&gt;(); Iterator&lt;JSONObject&gt; iterator = condetion.iterator(); Predicate preP = null; while(iterator.hasNext())&#123; JSONObject jsonObject = iterator.next(); //注意：这里用的root.join 因为我们要用qfjbxx对象里的字段作为条件就必须这样做join方法有很多重载，使用的时候可以多根据自己业务决断 Predicate p1 = cb.equal(root.join("qfjbxx").get("id").as(String.class),jsonObject.get("fzId").toString()); Predicate p2 = cb.equal(root.get("fzcc").as(String.class),jsonObject.get("ccId").toString()); if(preP!=null)&#123; preP = cb.or(preP,cb.and(p1,p2)); &#125;else&#123; preP = cb.and(p1,p2); &#125; &#125; JSONObject jsonSearch=(JSONObject) search.get(0); Predicate p3=null; if(null!=jsonSearch.get("xm")&amp;&amp;jsonSearch.get("xm").toString().length()&gt;0)&#123; p3=cb.like(root.join("criminalInfo").get("xm").as(String.class),"%"+jsonSearch.get("xm").toString()+"%"); &#125; Predicate p4=null; if(null!=jsonSearch.get("fzmc")&amp;&amp;jsonSearch.get("fzmc").toString().length()&gt;0)&#123; p4=cb.like(root.join("qfjbxx").get("fzmc").as(String.class),"%"+jsonSearch.get("fzmc").toString()+"%"); &#125; Predicate preA; if(null!=p3&amp;&amp;null!=p4)&#123; Predicate preS =cb.and(p3,p4); preA =cb.and(preP,preS); &#125;else if(null==p3&amp;&amp;null!=p4)&#123; preA=cb.and(preP,p4); &#125;else if(null!=p3&amp;&amp;null==p4)&#123; preA=cb.and(preP,p3); &#125;else&#123; preA=preP; &#125; predicate.add(preA); Predicate[] pre = new Predicate[predicate.size()]; query.where(predicate.toArray(pre)); return query.getRestriction(); &#125; &#125;;&#125;/** * */private List&lt;SubAcctTrxJnlPo&gt; getRechargeList(final String trxDate, final String serviceCenterId) &#123; return subAcctTrxJnlRepository.findAll(new Specification&lt;SubAcctTrxJnlPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;SubAcctTrxJnlPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions .add(cb.exists(getSubQuery(query, cb, root.&lt;String&gt; get("acctNo"), serviceCenterId))); expressions.add(cb.equal(root.&lt;String&gt; get("trxDate"), trxDate)); expressions.add(cb.equal(root.&lt;String&gt; get("useType"), EUseType.RECHARGE)); return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; acctNo, String serviceCenterId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;AcctPo&gt; rAcct = subQuery.from(AcctPo.class); Root&lt;InvestorInfoPo&gt; rInvestor = subQuery.from(InvestorInfoPo.class); return subQuery.select(rAcct.&lt;String&gt; get("acctNo")) .where(cb.and(cb.equal(rAcct.&lt;String&gt; get("acctNo"), acctNo), cb.equal(rAcct.&lt;String&gt; get("userId"), rInvestor.&lt;String&gt; get("userId")), cb.equal(rInvestor.&lt;String&gt; get("serviceCenterId"), serviceCenterId))); &#125; &#125;);&#125;/** * */@Transactional(readOnly = true)public List&lt;AcctDto&gt; getAcctInfoList(final List&lt;String&gt; userIdList, final List&lt;String&gt; groupIds, final List&lt;EBizRole&gt; bizRoles)&#123; Specification&lt;AcctPo&gt; spec = new Specification&lt;AcctPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;AcctPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); if(userIdList!=null&amp;&amp;!userIdList.isEmpty())&#123; expressions.add(root.&lt;String&gt;get("userId").in(userIdList)); &#125; if(bizRoles!=null &amp;&amp; !bizRoles.isEmpty())&#123; expressions.add(cb.exists(getRolesSubQuery(query, cb, root.&lt;String&gt;get("userId"), getRoleIds(bizRoles)))); &#125; if(groupIds!=null &amp;&amp; !groupIds.isEmpty())&#123; expressions.add(cb.exists(getGroupsSubQuery(query, cb, root.&lt;String&gt;get("userId"), getGroupIds(groupIds)))); &#125; return predicate; &#125; private Subquery&lt;String&gt; getRolesSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; userId, Set&lt;String&gt; roleIds) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;UserRolePo&gt; param = subQuery.from(UserRolePo.class); return subQuery.select(param.&lt;String&gt;get("userId")).where( cb.and(cb.equal(param.get("userId"), userId), param.&lt;String&gt;get("roleId").in(roleIds) )); &#125; private Subquery&lt;String&gt; getGroupsSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; userId, Set&lt;String&gt; groupIds) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;GroupUserPo&gt; param = subQuery.from(GroupUserPo.class); return subQuery.select(param.&lt;String&gt;get("userId")).where( cb.and(cb.equal(param.get("userId"), userId), param.&lt;String&gt;get("groupId").in(groupIds) )); &#125; private Set&lt;String&gt; getRoleIds(List&lt;EBizRole&gt; bizRoles)&#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); for(EBizRole role:bizRoles)&#123; sets.add(role.getRoleId()); &#125; return sets; &#125; private Set&lt;String&gt; getGroupIds(List&lt;String&gt; groupIds)&#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); for(String gid:groupIds)&#123; sets.add(gid); &#125; return sets; &#125; &#125;; List&lt;AcctPo&gt; list = acctRepo.findAll(spec); return packItems(list);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 线程池的使用]]></title>
      <url>%2F2017%2F03%2F27%2Fjava-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[123import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 线程池. * * @author chenwulou * */public class TestThreadPool &#123; /** * 下面解释下一下构造器中各个参数的含义： * * corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，&lt;/br&gt; * 线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads() * 或者prestartCoreThread()方法，&lt;/br&gt; * 从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。&lt;/br&gt; * 默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务， * 当线程池中的线程数目达到corePoolSize后，&lt;/br&gt; * 就会把到达的任务放到缓存队列当中；&lt;/br&gt; * maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；&lt;/br&gt; * keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。&lt;/br&gt; * 默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，&lt;/br&gt; * 直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，&lt;/br&gt; * 如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。&lt;/br&gt; * 但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，&lt;/br&gt; * keepAliveTime参数也会起作用，直到线程池中的线程数为0；&lt;/br&gt; * unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：&lt;/br&gt; * TimeUnit.DAYS; //天&lt;/br&gt; * TimeUnit.HOURS; //小时&lt;/br&gt; * TimeUnit.MINUTES; //分钟&lt;/br&gt; * TimeUnit.SECONDS; //秒&lt;/br&gt; * TimeUnit.MILLISECONDS; //毫秒&lt;/br&gt; * TimeUnit.MICROSECONDS; //微妙&lt;/br&gt; * TimeUnit.NANOSECONDS; //纳秒&lt;/br&gt; * * @param args */ public static void main(String[] args) &#123; //自动创建线程池// ExecutorService executorService = Executors.newCachedThreadPool();// ExecutorService executorService = Executors.newSingleThreadExecutor();// ExecutorService executorService = Executors.newFixedThreadPool(3); ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 15, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for (int i = 0; i &lt; 15; i++) &#123; MyTask myTask = new MyTask(i);// Thread t = new Thread(myTask); //设置优先级// t.setPriority(1); executor.execute(myTask); System.out.println("线程池中线程数目：" + executor.getPoolSize() + "，队列中等待执行的任务数目：" + executor.getQueue().size() + "，已执行完毕的任务数目：" + executor.getCompletedTaskCount()); &#125; executor.shutdown();// executor.shutdownNow(); &#125;&#125;class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println("正在执行task " + taskNum); try &#123;// Thread.sleep(10); Thread.currentThread().sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("task " + taskNum + "执行完毕"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java内存溢出总结]]></title>
      <url>%2F2017%2F03%2F27%2Fjava%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[首先我们来说说java虚拟机的构成吧: 他是由程序计数器,堆,java虚拟机栈,本地方法栈,方法区这几块构成的, 堆是用来存放对象和数组的,这里我们就可以设计一个无限创造对象来模拟堆溢出. 1234567891011121314151617181920212223/** * 堆溢出 * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space * @author chenwulou */public class HeapLeak &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); while (true) &#123; list.add(new HeapLeak.method()); &#125; &#125; static class method &#123; &#125;&#125; 栈是用来存放基本数据类型，对象引用，方法等等这些东西的,这里我们就能用无限递归来模拟栈溢出 12345678910111213141516171819202122232425/** * 栈溢出 * Exception in thread "main" java.lang.StackOverflowError * @author chenwulou */public class StackLeak &#123; public static void main(String[] args) &#123; method(); &#125; public static void method() &#123; method(); &#125;&#125; 方法区用来存放每个class的结构,比如说运行时常量池、域、方法数据、方法体、构造函数、包括类中的专用方法、实例初始化、接口初始化。cglib可以直接操作字节码，也可以动态产生Class，下面通过cglib来演示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 方法区溢出 * Exception in thread "main" java.lang.NoClassDefFoundError * @author chenwulou */public class MethodAreaLeak &#123;public static void main(String[] args) &#123;while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create();&#125;&#125;class OOMObject &#123;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring事务的隔离级别和传播属性]]></title>
      <url>%2F2017%2F03%2F27%2Fspring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[前言对于事务的理解,在日常的开发过程中,相对来说还是比较重要的.不同的业务功能,所需要的事务传播属性以及隔离级别都是不一样的,当然,大多数情况下,我们使用默认的配置就行了,但是,某些特殊情境,我们就需要特殊配置.这里我就大概来说一说事务. 事务的传播属性: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*** Support a current transaction, create a new one if none exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;This is the default setting of a transaction annotation.*/// 支持当前事务,如果没有,创建一个新事务.(默认属性,也是最常用的)REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),/*** Support a current transaction, execute non-transactionally if none exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: For transaction managers with transaction synchronization,* PROPAGATION_SUPPORTS is slightly different from no transaction at all,* as it defines a transaction scope that synchronization will apply for.* As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)* will be shared for the entire specified scope. Note that this depends on* the actual synchronization configuration of the transaction manager.* @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization*///支持当前事务,如果没有事务,就以非事务状态执行SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),/*** Support a current transaction, throw an exception if none exists.* Analogous to EJB transaction attribute of the same name.*///支持当前事务,如果没有事务,抛出异常MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),/*** Create a new transaction, suspend the current transaction if one exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: Actual transaction suspension will not work on out-of-the-box* on all transaction managers. This in particular applies to JtaTransactionManager,* which requires the &#123;@code javax.transaction.TransactionManager&#125; to be* made available it to it (which is server-specific in standard J2EE).* @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager*///新建事务,若当前存在事务,则挂起当前事务REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),/*** Execute non-transactionally, suspend the current transaction if one exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: Actual transaction suspension will not work on out-of-the-box* on all transaction managers. This in particular applies to JtaTransactionManager,* which requires the &#123;@code javax.transaction.TransactionManager&#125; to be* made available it to it (which is server-specific in standard J2EE).* @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager*///以非事务方式执行.若当前存在事务,则挂起当前事务NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),/*** Execute non-transactionally, throw an exception if a transaction exists.* Analogous to EJB transaction attribute of the same name.*///以非事务方式执行.若当前存在事务,则跑出异常NEVER(TransactionDefinition.PROPAGATION_NEVER),/*** Execute within a nested transaction if a current transaction exists,* behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB.* &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific* transaction managers. Out of the box, this only applies to the JDBC* DataSourceTransactionManager when working on a JDBC 3.0 driver.* Some JTA providers might support nested transactions as well.* @see org.springframework.jdbc.datasource.DataSourceTransactionManager*///执行嵌套事务,如果当前存在事务NESTED(TransactionDefinition.PROPAGATION_NESTED); 事务的隔离级别: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/*** Use the default isolation level of the underlying datastore.* All other levels correspond to the JDBC isolation levels.* @see java.sql.Connection*///使用数据库默认的隔离级别DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),/*** A constant indicating that dirty reads, non-repeatable reads and phantom reads* can occur. This level allows a row changed by one transaction to be read by* another transaction before any changes in that row have been committed* (a "dirty read"). If any of the changes are rolled back, the second* transaction will have retrieved an invalid row.* @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED*///读取未提交数据(级别最低,允许事务读取另一个事务未提交的数据)READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),/*** A constant indicating that dirty reads are prevented; non-repeatable reads* and phantom reads can occur. This level only prohibits a transaction* from reading a row with uncommitted changes in it.* @see java.sql.Connection#TRANSACTION_READ_COMMITTED*///读取提交数据(允许事务读取另一个事务提交的数据)READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),/*** A constant indicating that dirty reads and non-repeatable reads are* prevented; phantom reads can occur. This level prohibits a transaction* from reading a row with uncommitted changes in it, and it also prohibits* the situation where one transaction reads a row, a second transaction* alters the row, and the first transaction rereads the row, getting* different values the second time (a "non-repeatable read").* @see java.sql.Connection#TRANSACTION_REPEATABLE_READ*///可重复读REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),/*** A constant indicating that dirty reads, non-repeatable reads and phantom* reads are prevented. This level includes the prohibitions in* &#123;@code ISOLATION_REPEATABLE_READ&#125; and further prohibits the situation* where one transaction reads all rows that satisfy a &#123;@code WHERE&#125;* condition, a second transaction inserts a row that satisfies that* &#123;@code WHERE&#125; condition, and the first transaction rereads for the* same condition, retrieving the additional "phantom" row in the second read.* @see java.sql.Connection#TRANSACTION_SERIALIZABLE*///顺序执行读取(级别最高,最可靠)SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); 下面整理一张表. 丢失更新 脏读 非重复读 覆盖更新 幻读 未提交读 N Y Y Y Y 已提交读 N N Y Y Y 可重复读 N N N N Y 串行化(顺序读) N N N N N 名词解释 未提交读:允许读取未提交数据,如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。 已提交读:当一个事务开始了,则只有等这个事务提交结束了,才允许其他事务读, 可重复读: 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务 串行化读:按照顺序,一个事务一个事务的执行. 丢失更新:撤销一个事务时，把其他事务已提交的更新数据覆盖（A和B事务并发执行，A事务执行更新后，提交；B事务在A事务更新后，B事务结束前也做了对该行数据的更新操作，然后回滚，则两次更新操作都丢失了）。 脏读:一个事务读到另一个事务未提交的更新数据（事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的）。 不可重复读:一个事务读到另一个事务已提交的更新数据（一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果）。 覆盖更新:这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据（即A事务更新数据，然后B事务更新该数据，A事务查询发现自己更新的数据变了）。 虚读（幻读）:一个事务读到另一个事务已提交的新插入的数据（A和B事务并发执行，A事务查询数据，B事务插入或者删除数据，A事务再次查询发现结果集中有以前没有的数据或者以前有的数据消失了）。 oracle 支持Read Committed和 Serializable和oracle特有的Read-only 这三种事务隔离级别,默认Read Committed mysql支持Read Uncommitted, Read Committed, Repeatable Read,Serializable, 默认Repeatable Read]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象拷贝类PropertyUtils，BeanUtils，BeanCopier]]></title>
      <url>%2F2017%2F03%2F27%2F%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%B1%BBPropertyUtils%EF%BC%8CBeanUtils%EF%BC%8CBeanCopier%2F</url>
      <content type="text"><![CDATA[目前流行的较为公用认可的工具类：Apache的两个版本：（反射机制）12org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest, Object orig) Spring版本：（反射机制）1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高）1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 原理简介反射类型：（apache）都使用静态类调用，最终转化虚拟机中两个单例的工具对象。1234public BeanUtilsBean()&#123; this(new ConvertUtilsBean(), new PropertyUtilsBean());&#125; ConvertUtilsBean可以通过ConvertUtils全局自定义注册。1ConvertUtils.register(new DateConvert(), java.util.Date.class); PropertyUtilsBean的copyProperties方法实现了拷贝的算法。1、 动态bean：1orig instanceof DynaBean：Object value = ((DynaBean)orig).get(name); 然后把value复制到动态bean类2、 Map类型：orig instanceof Map：key值逐个拷贝3、 其他普通类：：从beanInfo【每一个对象都有一个缓存的bean信息，包含属性字段等】取出name，然后把sourceClass和targetClass逐个拷贝 Cglib类型：BeanCopier12copier = BeanCopier.create(source.getClass(), target.getClass(), false);copier.copy(source, target, null); Create对象过程：产生sourceClass-》TargetClass的拷贝代理类，放入jvm中，所以创建的代理类的时候比较耗时。最好保证这个对象的单例模式，可以参照最后一部分的优化方案。创建过程：源代码见1jdk：net.sf.cglib.beans.BeanCopier.Generator.generateClass(ClassVisitor) 1、 获取sourceClass的所有public get 方法-》PropertyDescriptor[] getters2、 获取TargetClass 的所有 public set 方法-》PropertyDescriptor[] setters3、 遍历setters的每一个属性，执行4和54、 按setters的name生成sourceClass的所有setter方法-》PropertyDescriptor getter【不符合javabean规范的类将会可能出现空指针异常】5、 PropertyDescriptor[] setters-》PropertyDescriptor setter6、 将setter和getter名字和类型 配对，生成代理类的拷贝方法。Copy属性过程：调用生成的代理类，代理类的代码和手工操作的代码很类似，效率非常高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[grunt安装和使用]]></title>
      <url>%2F2017%2F03%2F27%2Fgrunt%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装gruntGrunt运行离不开NodeJS和NPM。因此要使用Grunt首要的条件，你的系统需要安装NodeJS和NPM。 安装NodeJS node安装的方法很多，如果是wiondow系统,可以直接进入Nodejs官网中下载各系统所需要的安装包进行安装。 安装NPM 装好NodeJS后，可以在你的终端执行下面的命令安装NPM: curl http://npmjs.org/install.sh | sh 如果这样安装失败，或许你要在上面的命令之前加上sudo，并按提示输入你的用户密码。 如果需要检验安装NodeJS或NPM是否要成功，可以通过下面的命令来检验： $ node -v v0.10.13 $ npm -v 1.3.2 这样你的NodeJS和NPM表示安装成功。 安装CLI 为了方便使用Grunt，你应该在全局范围内安装Grunt的命令行接口(CLI)。在命令行中执行： $ npm install -g grunt-cli 这条命令将会把grunt命令植入到你的系统路径中，这样就允许你从任意目录中运行Grunt(定位到任意目录运行grunt命令) 运行grunt 进入到Gruntfile.js的目录,在命令行执行： $ npm install 等待命令执行后，再执行: $ grunt 即可把要压缩处理的文件处理到Gruntfile.js配置的目录 前端开发同学在开发过程中不需要每次都运行上面的grunt命令，可以在命令行运行一个： $ grunt dev 即可时时监听修改过的文件。 不能运行npm install时,运行下面的命令…1.通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 2.命令行指定 npm –registry https://registry.npm.taobao.org info underscore 3.编辑~/.npmrc加入下面内容 registry = https://registry.npm.taobao.org npm可能是默认的proxy http://127.0.0.1.8087 $ npm config set proxy null 把代理去掉就行了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse远程debug]]></title>
      <url>%2F2017%2F03%2F27%2Feclipse%E8%BF%9C%E7%A8%8Bdebug%2F</url>
      <content type="text"><![CDATA[远程Debug(Jboss-eap-6.2为例): 服务器: ..\bin\standalone.conf #JAVA_OPTS=”$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n” 打开注释 eclipse: 右键项目-&gt;debug as-&gt;debug configuration-&gt;remote java application host:服务器IP port:8787(可以自己改跟address=xxxx,一样) 注意, 同时只能一个用户远程debug.否则会报错. 远程服务器部署的代码跟本地要一样.]]></content>
    </entry>

    
  
  
</search>
