<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[常用工具]]></title>
      <url>%2F2017%2F03%2F28%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[远程连接服务器: winscp/putty/Xshell ftp: Xftp mongodbGUI: Robomongo 编辑器: notepad++, vim 接口调试: postman 监控分析: BTrace]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux日常记录]]></title>
      <url>%2F2017%2F03%2F27%2FLinux%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[linux开机启动服务目录:/etc/init.d 启动redis客户端:/usr/local/redis-3.2.4/src/redis-cli Linux下剪切拷贝命令 命令格式: mv source dest mv: 命令字 source: 源文件 dest: 目的地址 Linux下拷贝命令 命令格式：cp [-rf] source dest 使用备注：源文件在前，目标文件在后。 参数说明： -r 若 source 中含有目录，则将目录下之档案亦皆依序拷贝至目的地。-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。 删除命令 1、删除home目录下的test目录 rm /home/test 2、这种不带参数的删除方法经常会提示无法删除，因为权限不够。 rm -r /home/test 3、-r是递归的删除参数表中的目录及其子目录。 目录将被清空并且删除。 当删除目录包含的具有写保护的文件时用户通常是被提示的。 rm -rf /home/test -4、f是不提示用户，删除目录下的所有文件。请注意检查路径，输成别的目录就悲剧了。 rm -ir /home/test 5、-i是交互模式。使用这个选项，rm命令在删除任何文件前提示用户确认。 Yum软件仓库 命令 作用 yum r…epolist all 列出所有仓库。 yum list all 列出仓库中所有软件包 yum info 软件包名称 查看软件包信息 yum install 软件包名称 安装软件包 yum reinstall 软件包名称 重新安装软件包 yum update 软件包名称 升级软件包 yum remove 软件包 移除软件包 yum clean all 清除所有仓库缓存 yum check-update 检查可更新的软件包 yum grouplist 查看系统中已经安装的软件包组 yum groupinstall 软件包组 安装指定的软件包组 yum groupremove软件包组 移除指定的软件包组 yum groupinfo 软件包组 查询指定的软件包组信息 systemctl管理服务的启动、重启、停止、重载、查看状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 service foo start systemctl start foo.service 启动服务 service foo restart systemctl restart foo.service 重启服务 service foo stop systemctl stop foo.service 停止服务 service foo reload systemctl reload foo.service 重新加载配置文件（不终止服务） service foo status systemctl status foo.service 查看服务状态 systemctl设置服务的开机启动、不启动、查看各级别下服务启动状态的命令： Sysvinit命令(红帽RHEL6系统) Systemctl命令（红帽RHEL7系统） 作用 chkconfig foo on systemctl enable foo.service 开机自动启动 chkconfig foo off systemctl disable foo.service 开机不自动启动 chkconfig foo systemctl is-enabled foo.service 查看特定服务是否为开机自启动 chkconfig –list systemctl list-unit-files –type=service 查看各个级别下服务的启动与禁用情况]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb操作日志]]></title>
      <url>%2F2017%2F03%2F27%2Fmongodb%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223// 根据查询结果,替换某个字段的字符串// 模糊查询vcPicUrl中有'http:'字段的结果var list = db.getCollection('tbArticle').find(&#123;"vcPicUrl":/http:/&#125;);// var index = 0;// list.toArray();// while(list.hasNext())&#123;// var url = list[index].vcPicUrl;// print(url);// var rurl = url.replace('http:','https:');// print(rurl);// db.getCollection('tbArticle').update(&#123;"_id":list[index]._id&#125;, &#123;$set:&#123;'vcPicUrl':rurl&#125;&#125;);// index=index+1;// &#125;print(list.length());// 将vcPicUrl中的http: 替换成 https: for (var i = 0; i &lt; list.length(); i++) &#123; var article = list[i]; var url = article.vcPicUrl; var rurl = url.replace('http:','https:'); db.getCollection('tbArticle').update(&#123;"_id":article._id&#125;, &#123;$set:&#123;'vcPicUrl':rurl&#125;&#125;); &#125; print("success")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring data jpa 查询使用案例]]></title>
      <url>%2F2017%2F03%2F27%2Fspring-data-jpa-%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503/** * */public String getSumAmount(final AcctDtlSearchDto searchDto, final ERecvPayFlag recvPayFlag) &#123; String startDate = searchDto.getStartDate(); String endDate = searchDto.getEndDate(); EUseType useType = searchDto.getUseType(); CriteriaBuilder builder = em.getCriteriaBuilder(); CriteriaQuery&lt;BigDecimal&gt; query = builder.createQuery(BigDecimal.class); Root&lt;SubAcctTrxJnlPo&gt; root = query.from(SubAcctTrxJnlPo.class); Predicate predicate = builder.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); Expression&lt;BigDecimal&gt; sumTrxAmt = builder.sum(root.&lt;BigDecimal&gt; get("trxAmt")); if (StringUtils.isNotBlank(startDate)) &#123; expressions.add(builder.greaterThanOrEqualTo(root.&lt;String&gt; get("trxDate"), startDate)); &#125; if (StringUtils.isNotBlank(endDate)) &#123; expressions.add(builder.lessThanOrEqualTo(root.&lt;String&gt; get("trxDate"), endDate)); &#125; if (EUseType.ALL != useType) &#123; expressions.add(builder.equal(root.&lt;EUseType&gt; get("useType"), useType)); &#125; if (null != recvPayFlag) &#123; expressions.add(builder.equal(root.&lt;ERecvPayFlag&gt; get("recvPayFlag"), recvPayFlag)); &#125; query.where(predicate); query.select(sumTrxAmt); BigDecimal result = em.createQuery(query).getSingleResult(); result = (null == result ? BigDecimal.ZERO : result); return result.toString(); &#125; /** * */private BigDecimal getWarrantedProjectAmt(final String userId) &#123; List&lt;ProjectPo&gt; list = projectRepository.findAll(new Specification&lt;ProjectPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ProjectPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.equal(root.&lt;String&gt; get("wrtrId"), userId)); List&lt;EProjStatus&gt; inStatus = Arrays.asList(EProjStatus.RISK_AUDIT, EProjStatus.RISK_RATING); expressions.add(root.&lt;EProjStatus&gt; get("status").in(inStatus)); return predicate; &#125; &#125;); BigDecimal warrantAmt = BigDecimal.ZERO; for (ProjectPo proj : list) &#123; warrantAmt = warrantAmt.add(proj.getProjectAmt()); &#125; return warrantAmt;&#125;/** * */public List&lt;ProdServItemDto&gt; getItems(final ProdServItemSearchDto searchDto, final String currUserId)&#123; long times = System.currentTimeMillis(); List&lt;ProdServInfoPo&gt; list = prodServInfoRepo.findAll(new Specification&lt;ProdServInfoPo&gt;()&#123; @Override public Predicate toPredicate(Root&lt;ProdServInfoPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); String workDate = CommonBusinessUtil.getCurrentWorkDate(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); // 已授信过滤 expressions.add(cb.exists(getProdServParamSubQuery(query, cb, workDate, root.&lt;String&gt;get("userId")))); if(StringUtils.isNotBlank(searchDto.getName()))&#123; expressions.add(cb.like(root.&lt;EnterpriseInfoPo&gt;get("enterpriseInfoPo").&lt;String&gt;get("name"), "%"+searchDto.getName()+"%")); &#125; if(StringUtils.isNotBlank(searchDto.getTelephone()))&#123; expressions.add(cb.like(root.&lt;EnterpriseInfoPo&gt;get("enterpriseInfoPo").&lt;String&gt;get("telephone"), "%"+searchDto.getTelephone()+"%")); &#125; Expression&lt;Boolean&gt; servProvTypes = root.&lt;EWarrantProdServProvType&gt; get("servProvType").in(EWarrantProdServProvType.MICRO_CMPY, EWarrantProdServProvType.WRTR_CMPY); Expression&lt;Boolean&gt; unionServProvType = cb.and( cb.equal(root.&lt;EWarrantProdServProvType&gt; get("servProvType"), EWarrantProdServProvType.UNION_CMPY), cb.exists(getSubQuery(query, cb, currUserId, root.&lt;String&gt; get("userId")))); expressions.add(cb.or(servProvTypes, unionServProvType)); /** 如果是小贷,不显示自己 **/ expressions.add(cb.notEqual(root.&lt;String&gt;get("userId"), currUserId)); return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String fncrId, Path&lt;String&gt; prodServUserId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;ProdServInfoPo&gt; prodServ = subQuery.from(ProdServInfoPo.class); Join&lt;ProdServInfoPo, ProdServGroupPo&gt; prodServGroup = prodServ.join("prodServGroupList", JoinType.INNER); Join&lt;ProdServGroupPo, GroupPo&gt; group = prodServGroup.join("groupPo", JoinType.INNER); Join&lt;GroupPo, GroupUserPo&gt; groupUser = group.join("groupUserPoSet", JoinType.INNER); Join&lt;GroupUserPo, FncrInfoPo&gt; fncrInfo = groupUser.join("fncrInfoPo", JoinType.INNER); return subQuery.select(prodServ.&lt;String&gt;get("userId")).where( cb.and(cb.equal(prodServ.get("userId"), prodServUserId), cb.equal(fncrInfo.&lt;String&gt; get("userId"), fncrId))); &#125; private Subquery&lt;String&gt; getProdServParamSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String workDate, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;ProdServParamPo&gt; param = subQuery.from(ProdServParamPo.class); return subQuery.select(param.&lt;String&gt;get("userId")).where( cb.and(cb.equal(param.get("userId"), userId), cb.lessThanOrEqualTo(param.&lt;String&gt;get("startDate"), workDate), cb.greaterThanOrEqualTo(param.&lt;String&gt;get("endDate"), workDate) )); &#125; &#125;); List&lt;ProdServItemDto&gt; items = new ArrayList&lt;ProdServItemDto&gt;(); for(ProdServInfoPo serv: list)&#123; EnterpriseInfoPo ent = serv.getEnterpriseInfoPo(); ProdServItemDto item = new ProdServItemDto(); item.setUserId(serv.getUserId()); item.setWrtrKind(serv.getWrtrKind()); item.setServProvType(serv.getServProvType()); item.setQq(ent.getQq()); item.setName(ent.getName()); item.setAddress(ent.getAddress()); item.setZipCode(ent.getZipCode()); item.setContractName(ent.getContractName()); item.setTelephone(ent.getTelephone()); item.setWrtrFileId(serv.getWrtrFileId()); items.add(item); &#125; logger.debug("cost times is &#123;&#125; ms", (System.currentTimeMillis()-times)); return items; &#125; //expressions.add(cb.greaterThanOrEqualTo(root.&lt;Date&gt; get("createTs"), DateUtils.getStartDate(DateUtils.getDate(fromDate, YYYY_MM_DD))));//expressions.add(cb.lessThanOrEqualTo(root.&lt;Date&gt; get("createTs"), DateUtils.getEndDate(DateUtils.getDate(toDate, YYYY_MM_DD))));/***公告查询,这里主要看根据roleIds 不同用户显示不同的公告*/public DataTablesResponseDto&lt;ArticleDto&gt; getArticlesForHome(final ArticleSearchDto searchCriteria) &#123;Pageable pageable = PaginationUtil.buildPageable(searchCriteria, PersistenceUtil.getIdName(ArticlePo.class));Specification&lt;ArticlePo&gt; specification = new Specification&lt;ArticlePo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ArticlePo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); if (null != searchCriteria) &#123; String nowDateStr = DateUtils.formatDate(new Date(), ApplicationConsts.DATE_FORMAT); EArticleStatus status = searchCriteria.getStatus(); EColumnCategory categoryId = searchCriteria.getCategoryId(); List&lt;Predicate&gt; predicateList = new ArrayList&lt;Predicate&gt;(); List&lt;UserRolePo&gt; userRolePoList = userRoleRepository.findByUserId(securityContext .getCurrentUserId()); for (UserRolePo userRole : userRolePoList) &#123; predicateList.add(cb.like(root.&lt;String&gt; get("roleIds"), "%" + userRole.getRoleId() + "%")); &#125; predicateList.add(cb.isNull(root.&lt;String&gt; get("roleIds"))); Predicate[] predicate1 = new Predicate[predicateList.size()]; Predicate predicate2 = cb.or(predicateList.toArray(predicate1)); expressions.add(predicate2); expressions.add(cb.lessThanOrEqualTo(root.&lt;String&gt; get("startDt"), nowDateStr)); expressions.add(cb.greaterThanOrEqualTo(root.&lt;String&gt; get("endDt"), nowDateStr)); if (EArticleStatus.ALL != status &amp;&amp; null != status) &#123; expressions.add(cb.equal(root.&lt;EArticleStatus&gt; get("status"), status)); &#125; if (EColumnCategory.ALL != categoryId &amp;&amp; null != categoryId) &#123; expressions.add(cb.equal(root.&lt;EColumnCategory&gt; get("categoryId"), categoryId)); &#125; &#125; return predicate; &#125;&#125;;Page&lt;ArticlePo&gt; articlePos = articleRepository.findAll(specification, pageable);DataTablesResponseDto&lt;ArticleDto&gt; result = PaginationUtil.populateFromPage(articlePos, new Function&lt;ArticlePo, ArticleDto&gt;() &#123; @Override public ArticleDto apply(ArticlePo po) &#123; ArticleDto articleDto = ConverterService.convert(po, ArticleDto.class); return articleDto; &#125; &#125;);return result;&#125;/** * */public BigDecimal getSumInvstAmt(String acctNo, String productId)&#123; CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;BigDecimal&gt; query = cb.createQuery(BigDecimal.class); Root&lt;ProductSubscribeDtlPo&gt; root = query.from(ProductSubscribeDtlPo.class); Expression&lt;BigDecimal&gt; subsAmtCm = cb.prod(root.&lt;BigDecimal&gt;get("unitAmt"), root.&lt;Long&gt;get("unit").as(BigDecimal.class)); Expression&lt;BigDecimal&gt; sumSubAmtQuery = cb.sum(subsAmtCm); Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); if(StringUtils.isNotBlank(acctNo))&#123; expressions.add(cb.equal(root.&lt;String&gt;get("acctNo"), acctNo)); &#125; if(StringUtils.isNotBlank(productId))&#123; expressions.add(cb.equal(root.&lt;String&gt;get("productId"), productId)); &#125; query.select(sumSubAmtQuery); query.where(predicate); BigDecimal result = em.createQuery(query).getSingleResult(); return result==null?BigDecimal.ZERO:result;&#125;/** * */private List&lt;ProjectPo&gt; getProjectByFncrId(final String fncrAcctNo) &#123; List&lt;ProjectPo&gt; list = projectRepository.findAll(new Specification&lt;ProjectPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ProjectPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.equal(root.&lt;String&gt; get("fncrAcctNo"), fncrAcctNo)); List&lt;EProjStatus&gt; inStatus = Arrays.asList(EProjStatus.INIT, EProjStatus.WRTR_AUDIT, EProjStatus.RISK_AUDIT, EProjStatus.RISK_RATING, EProjStatus.PASSED); expressions.add(root.&lt;EProjStatus&gt; get("status").in(inStatus)); return predicate; &#125; &#125;); return list;&#125;/** * */@Transactional(readOnly = true)public List&lt;SimpleMemberDto&gt; searchFncrMembers(final String keyWord) &#123; Sort sort = new Sort(Direction.ASC, PersistenceUtil.getIdName(AcctPo.class)); Pageable pageable = new PageRequest(0, 20, sort); Page&lt;AcctPo&gt; page = acctRepository.findAll(new Specification&lt;AcctPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;AcctPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.exists(getSubQuery(query, cb, root.&lt;String&gt;get("userId")))); String keyWordTrim = keyWord.trim(); if (StringUtils.isNotBlank(keyWord)) &#123; expressions.add(cb.or( cb.like(root.&lt;String&gt; get("acctNo"), "%" + keyWordTrim + "%"), cb.or(cb.like(root.&lt;UserPo&gt; get("userPo").&lt;String&gt; get("sname"), "%" + keyWordTrim + "%"), cb.like(root.&lt;UserPo&gt; get("userPo").&lt;String&gt; get("mobile"), "%" + keyWordTrim + "%")))); &#125; else &#123; expressions.add(cb.equal(root.&lt;String&gt; get("acctNo"), "0")); &#125; return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;SimpleUserPo&gt; suser = subQuery.from(SimpleUserPo.class); Join&lt;SimpleUserPo, FncrInfoPo&gt; fncrInfo = suser.join("fncrInfoPo", JoinType.INNER); return subQuery.select(suser.&lt;String&gt;get("userId")).where( cb.and(cb.equal(suser.get("userId"), userId), cb.equal(suser.get("userId"), fncrInfo.&lt;String&gt; get("userId")))); &#125; &#125;, pageable); List&lt;SimpleMemberDto&gt; items = new ArrayList&lt;SimpleMemberDto&gt;(); List&lt;AcctPo&gt; list = page.getContent(); for (AcctPo acct : list) &#123; SimpleMemberDto dto = new SimpleMemberDto(); UserPo userPo = acct.getUserPo(); StringBuilder label = new StringBuilder(); String sname = userPo.getSname(); String mobile = userPo.getMobile(); mobile = null == mobile ? "":mobile; String acctNo = acct.getAcctNo(); dto.setAcctNo(acctNo); dto.setSname(sname); dto.setMobile(mobile); label.append("姓名:"); label.append(sname); label.append(",手机号:"); label.append(mobile); label.append(",交易账号:"); label.append(acctNo); dto.setLabel(label.toString()); items.add(dto); &#125; return items;&#125;/** * */public List&lt;GroupUserInfoDto&gt; getInvsUsers(final GroupUserSearchDto searchDto) &#123; Specification&lt;UserPo&gt; spec = new Specification&lt;UserPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;UserPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions.add(cb.not(cb.exists(getSubQuery(query, cb, searchDto.getGroupId(), root.&lt;String&gt; get("userId"))))); if(searchDto!=null)&#123; if(StringUtils.isNotBlank(searchDto.getKeyWord()))&#123; expressions.add(cb.or( cb.like(root.&lt;String&gt;get("sname"), "%"+searchDto.getKeyWord()+"%"), cb.like(root.&lt;String&gt;get("nickName"), "%"+searchDto.getKeyWord()+"%"), cb.like(root.&lt;String&gt;get("mobile"), "%"+searchDto.getKeyWord()+"%"), cb.exists(getWorkUnitSubQuery(query, cb, searchDto.getKeyWord(), root.&lt;String&gt; get("userId"))) )); &#125; else&#123; // 未传关键字查询条件，则查询结果为空 expressions.add(cb.equal(root.&lt;String&gt;get("userId"),"0")); &#125; &#125; return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String groupId, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;GroupUserPo&gt; groupUsers = subQuery.from(GroupUserPo.class); return subQuery.select(groupUsers.&lt;String&gt;get("userId")).where( cb.and(cb.equal(groupUsers.&lt;String&gt; get("groupId"), groupId)), cb.equal(groupUsers.&lt;String&gt; get("userId"), userId)); &#125; private Subquery&lt;String&gt; getWorkUnitSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, String keyWord, Path&lt;String&gt; userId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;PersonalInfoPo&gt; personalInfo = subQuery.from(PersonalInfoPo.class); return subQuery.select(personalInfo.&lt;String&gt;get("userId")).where( cb.equal(personalInfo.&lt;String&gt; get("userId"), userId), cb.like(personalInfo.&lt;String&gt; get("workUnit"), "%"+searchDto.getKeyWord()+"%")); &#125; &#125;; List&lt;UserPo&gt; userList = userRepository.findAll(spec); List&lt;GroupUserInfoDto&gt; dtoList = new ArrayList&lt;GroupUserInfoDto&gt;(); for(UserPo ur:userList)&#123; GroupUserInfoDto dto = new GroupUserInfoDto(); dto.setName(ur.getSname()); dto.setNickName(ur.getNickName()); dto.setUserType(ur.getUserType()); dto.setUserId(ur.getUserId()); if(ur.getUserType() == EUserType.PERSON)&#123; PersonalInfoPo persnoalInfo = personalInfoRepository.findOne(ur.getUserId()); if(persnoalInfo!=null)&#123; dto.setWorkUnit(persnoalInfo.getWorkUnit()); &#125; &#125; else&#123; dto.setWorkUnit(null); &#125; dtoList.add(dto); &#125; return dtoList;&#125; /** * json */private Specification&lt;Qfjbxxdz&gt; getWhereClause(final JSONArray condetion,final JSONArray search) &#123; return new Specification&lt;Qfjbxxdz&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Qfjbxxdz&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; List&lt;Predicate&gt; predicate = new ArrayList&lt;&gt;(); Iterator&lt;JSONObject&gt; iterator = condetion.iterator(); Predicate preP = null; while(iterator.hasNext())&#123; JSONObject jsonObject = iterator.next(); //注意：这里用的root.join 因为我们要用qfjbxx对象里的字段作为条件就必须这样做join方法有很多重载，使用的时候可以多根据自己业务决断 Predicate p1 = cb.equal(root.join("qfjbxx").get("id").as(String.class),jsonObject.get("fzId").toString()); Predicate p2 = cb.equal(root.get("fzcc").as(String.class),jsonObject.get("ccId").toString()); if(preP!=null)&#123; preP = cb.or(preP,cb.and(p1,p2)); &#125;else&#123; preP = cb.and(p1,p2); &#125; &#125; JSONObject jsonSearch=(JSONObject) search.get(0); Predicate p3=null; if(null!=jsonSearch.get("xm")&amp;&amp;jsonSearch.get("xm").toString().length()&gt;0)&#123; p3=cb.like(root.join("criminalInfo").get("xm").as(String.class),"%"+jsonSearch.get("xm").toString()+"%"); &#125; Predicate p4=null; if(null!=jsonSearch.get("fzmc")&amp;&amp;jsonSearch.get("fzmc").toString().length()&gt;0)&#123; p4=cb.like(root.join("qfjbxx").get("fzmc").as(String.class),"%"+jsonSearch.get("fzmc").toString()+"%"); &#125; Predicate preA; if(null!=p3&amp;&amp;null!=p4)&#123; Predicate preS =cb.and(p3,p4); preA =cb.and(preP,preS); &#125;else if(null==p3&amp;&amp;null!=p4)&#123; preA=cb.and(preP,p4); &#125;else if(null!=p3&amp;&amp;null==p4)&#123; preA=cb.and(preP,p3); &#125;else&#123; preA=preP; &#125; predicate.add(preA); Predicate[] pre = new Predicate[predicate.size()]; query.where(predicate.toArray(pre)); return query.getRestriction(); &#125; &#125;;&#125;/** * */private List&lt;SubAcctTrxJnlPo&gt; getRechargeList(final String trxDate, final String serviceCenterId) &#123; return subAcctTrxJnlRepository.findAll(new Specification&lt;SubAcctTrxJnlPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;SubAcctTrxJnlPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); expressions .add(cb.exists(getSubQuery(query, cb, root.&lt;String&gt; get("acctNo"), serviceCenterId))); expressions.add(cb.equal(root.&lt;String&gt; get("trxDate"), trxDate)); expressions.add(cb.equal(root.&lt;String&gt; get("useType"), EUseType.RECHARGE)); return predicate; &#125; private Subquery&lt;String&gt; getSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; acctNo, String serviceCenterId) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;AcctPo&gt; rAcct = subQuery.from(AcctPo.class); Root&lt;InvestorInfoPo&gt; rInvestor = subQuery.from(InvestorInfoPo.class); return subQuery.select(rAcct.&lt;String&gt; get("acctNo")) .where(cb.and(cb.equal(rAcct.&lt;String&gt; get("acctNo"), acctNo), cb.equal(rAcct.&lt;String&gt; get("userId"), rInvestor.&lt;String&gt; get("userId")), cb.equal(rInvestor.&lt;String&gt; get("serviceCenterId"), serviceCenterId))); &#125; &#125;);&#125;/** * */@Transactional(readOnly = true)public List&lt;AcctDto&gt; getAcctInfoList(final List&lt;String&gt; userIdList, final List&lt;String&gt; groupIds, final List&lt;EBizRole&gt; bizRoles)&#123; Specification&lt;AcctPo&gt; spec = new Specification&lt;AcctPo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;AcctPo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Predicate predicate = cb.conjunction(); List&lt;Expression&lt;Boolean&gt;&gt; expressions = predicate.getExpressions(); if(userIdList!=null&amp;&amp;!userIdList.isEmpty())&#123; expressions.add(root.&lt;String&gt;get("userId").in(userIdList)); &#125; if(bizRoles!=null &amp;&amp; !bizRoles.isEmpty())&#123; expressions.add(cb.exists(getRolesSubQuery(query, cb, root.&lt;String&gt;get("userId"), getRoleIds(bizRoles)))); &#125; if(groupIds!=null &amp;&amp; !groupIds.isEmpty())&#123; expressions.add(cb.exists(getGroupsSubQuery(query, cb, root.&lt;String&gt;get("userId"), getGroupIds(groupIds)))); &#125; return predicate; &#125; private Subquery&lt;String&gt; getRolesSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; userId, Set&lt;String&gt; roleIds) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;UserRolePo&gt; param = subQuery.from(UserRolePo.class); return subQuery.select(param.&lt;String&gt;get("userId")).where( cb.and(cb.equal(param.get("userId"), userId), param.&lt;String&gt;get("roleId").in(roleIds) )); &#125; private Subquery&lt;String&gt; getGroupsSubQuery(CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb, Path&lt;String&gt; userId, Set&lt;String&gt; groupIds) &#123; Subquery&lt;String&gt; subQuery = query.subquery(String.class); Root&lt;GroupUserPo&gt; param = subQuery.from(GroupUserPo.class); return subQuery.select(param.&lt;String&gt;get("userId")).where( cb.and(cb.equal(param.get("userId"), userId), param.&lt;String&gt;get("groupId").in(groupIds) )); &#125; private Set&lt;String&gt; getRoleIds(List&lt;EBizRole&gt; bizRoles)&#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); for(EBizRole role:bizRoles)&#123; sets.add(role.getRoleId()); &#125; return sets; &#125; private Set&lt;String&gt; getGroupIds(List&lt;String&gt; groupIds)&#123; Set&lt;String&gt; sets = new HashSet&lt;String&gt;(); for(String gid:groupIds)&#123; sets.add(gid); &#125; return sets; &#125; &#125;; List&lt;AcctPo&gt; list = acctRepo.findAll(spec); return packItems(list);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 线程池的使用]]></title>
      <url>%2F2017%2F03%2F27%2Fjava-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * 线程池. * * @author chenwulou * */public class TestThreadPool &#123; /** * 下面解释下一下构造器中各个参数的含义： * * corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，&lt;/br&gt; * 线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads() * 或者prestartCoreThread()方法，&lt;/br&gt; * 从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。&lt;/br&gt; * 默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务， * 当线程池中的线程数目达到corePoolSize后，&lt;/br&gt; * 就会把到达的任务放到缓存队列当中；&lt;/br&gt; * maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；&lt;/br&gt; * keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。&lt;/br&gt; * 默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，&lt;/br&gt; * 直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，&lt;/br&gt; * 如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。&lt;/br&gt; * 但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，&lt;/br&gt; * keepAliveTime参数也会起作用，直到线程池中的线程数为0；&lt;/br&gt; * unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：&lt;/br&gt; * TimeUnit.DAYS; //天&lt;/br&gt; * TimeUnit.HOURS; //小时&lt;/br&gt; * TimeUnit.MINUTES; //分钟&lt;/br&gt; * TimeUnit.SECONDS; //秒&lt;/br&gt; * TimeUnit.MILLISECONDS; //毫秒&lt;/br&gt; * TimeUnit.MICROSECONDS; //微妙&lt;/br&gt; * TimeUnit.NANOSECONDS; //纳秒&lt;/br&gt; * * @param args */ public static void main(String[] args) &#123; //自动创建线程池// ExecutorService executorService = Executors.newCachedThreadPool();// ExecutorService executorService = Executors.newSingleThreadExecutor();// ExecutorService executorService = Executors.newFixedThreadPool(3); ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 15, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for (int i = 0; i &lt; 15; i++) &#123; MyTask myTask = new MyTask(i);// Thread t = new Thread(myTask); //设置优先级// t.setPriority(1); executor.execute(myTask); System.out.println("线程池中线程数目：" + executor.getPoolSize() + "，队列中等待执行的任务数目：" + executor.getQueue().size() + "，已执行完毕的任务数目：" + executor.getCompletedTaskCount()); &#125; executor.shutdown();// executor.shutdownNow(); &#125;&#125;class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println("正在执行task " + taskNum); try &#123;// Thread.sleep(10); Thread.currentThread().sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("task " + taskNum + "执行完毕"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java内存溢出总结]]></title>
      <url>%2F2017%2F03%2F27%2Fjava%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[首先我们来说说java虚拟机的构成吧: 他是由程序计数器,堆,java虚拟机栈,本地方法栈,方法区这几块构成的, 堆是用来存放对象和数组的,这里我们就可以设计一个无限创造对象来模拟堆溢出. 1234567891011121314151617181920212223/** * 堆溢出 * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space * @author chenwulou */public class HeapLeak &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); while (true) &#123; list.add(new HeapLeak.method()); &#125; &#125; static class method &#123; &#125;&#125; 栈是用来存放基本数据类型，对象引用，方法等等这些东西的,这里我们就能用无限递归来模拟栈溢出 12345678910111213141516171819202122232425/** * 栈溢出 * Exception in thread "main" java.lang.StackOverflowError * @author chenwulou */public class StackLeak &#123; public static void main(String[] args) &#123; method(); &#125; public static void method() &#123; method(); &#125;&#125; 方法区用来存放每个class的结构,比如说运行时常量池、域、方法数据、方法体、构造函数、包括类中的专用方法、实例初始化、接口初始化。cglib可以直接操作字节码，也可以动态产生Class，下面通过cglib来演示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 方法区溢出 * Exception in thread "main" java.lang.NoClassDefFoundError * @author chenwulou */public class MethodAreaLeak &#123;public static void main(String[] args) &#123;while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create();&#125;&#125;class OOMObject &#123;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring事务的隔离级别和传播属性]]></title>
      <url>%2F2017%2F03%2F27%2Fspring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[前言对于事务的理解,在日常的开发过程中,相对来说还是比较重要的.不同的业务功能,所需要的事务传播属性以及隔离级别都是不一样的,当然,大多数情况下,我们使用默认的配置就行了,但是,某些特殊情境,我们就需要特殊配置.这里我就大概来说一说事务. 事务的传播属性: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*** Support a current transaction, create a new one if none exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;This is the default setting of a transaction annotation.*/// 支持当前事务,如果没有,创建一个新事务.(默认属性,也是最常用的)REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),/*** Support a current transaction, execute non-transactionally if none exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: For transaction managers with transaction synchronization,* PROPAGATION_SUPPORTS is slightly different from no transaction at all,* as it defines a transaction scope that synchronization will apply for.* As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)* will be shared for the entire specified scope. Note that this depends on* the actual synchronization configuration of the transaction manager.* @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization*///支持当前事务,如果没有事务,就以非事务状态执行SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),/*** Support a current transaction, throw an exception if none exists.* Analogous to EJB transaction attribute of the same name.*///支持当前事务,如果没有事务,抛出异常MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),/*** Create a new transaction, suspend the current transaction if one exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: Actual transaction suspension will not work on out-of-the-box* on all transaction managers. This in particular applies to JtaTransactionManager,* which requires the &#123;@code javax.transaction.TransactionManager&#125; to be* made available it to it (which is server-specific in standard J2EE).* @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager*///新建事务,若当前存在事务,则挂起当前事务REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),/*** Execute non-transactionally, suspend the current transaction if one exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: Actual transaction suspension will not work on out-of-the-box* on all transaction managers. This in particular applies to JtaTransactionManager,* which requires the &#123;@code javax.transaction.TransactionManager&#125; to be* made available it to it (which is server-specific in standard J2EE).* @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager*///以非事务方式执行.若当前存在事务,则挂起当前事务NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),/*** Execute non-transactionally, throw an exception if a transaction exists.* Analogous to EJB transaction attribute of the same name.*///以非事务方式执行.若当前存在事务,则跑出异常NEVER(TransactionDefinition.PROPAGATION_NEVER),/*** Execute within a nested transaction if a current transaction exists,* behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB.* &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific* transaction managers. Out of the box, this only applies to the JDBC* DataSourceTransactionManager when working on a JDBC 3.0 driver.* Some JTA providers might support nested transactions as well.* @see org.springframework.jdbc.datasource.DataSourceTransactionManager*///执行嵌套事务,如果当前存在事务NESTED(TransactionDefinition.PROPAGATION_NESTED); 事务的隔离级别: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/*** Use the default isolation level of the underlying datastore.* All other levels correspond to the JDBC isolation levels.* @see java.sql.Connection*///使用数据库默认的隔离级别DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),/*** A constant indicating that dirty reads, non-repeatable reads and phantom reads* can occur. This level allows a row changed by one transaction to be read by* another transaction before any changes in that row have been committed* (a "dirty read"). If any of the changes are rolled back, the second* transaction will have retrieved an invalid row.* @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED*///读取未提交数据(级别最低,允许事务读取另一个事务未提交的数据)READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),/*** A constant indicating that dirty reads are prevented; non-repeatable reads* and phantom reads can occur. This level only prohibits a transaction* from reading a row with uncommitted changes in it.* @see java.sql.Connection#TRANSACTION_READ_COMMITTED*///读取提交数据(允许事务读取另一个事务提交的数据)READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),/*** A constant indicating that dirty reads and non-repeatable reads are* prevented; phantom reads can occur. This level prohibits a transaction* from reading a row with uncommitted changes in it, and it also prohibits* the situation where one transaction reads a row, a second transaction* alters the row, and the first transaction rereads the row, getting* different values the second time (a "non-repeatable read").* @see java.sql.Connection#TRANSACTION_REPEATABLE_READ*///可重复读REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),/*** A constant indicating that dirty reads, non-repeatable reads and phantom* reads are prevented. This level includes the prohibitions in* &#123;@code ISOLATION_REPEATABLE_READ&#125; and further prohibits the situation* where one transaction reads all rows that satisfy a &#123;@code WHERE&#125;* condition, a second transaction inserts a row that satisfies that* &#123;@code WHERE&#125; condition, and the first transaction rereads for the* same condition, retrieving the additional "phantom" row in the second read.* @see java.sql.Connection#TRANSACTION_SERIALIZABLE*///顺序执行读取(级别最高,最可靠)SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); 下面整理一张表. 丢失更新 脏读 非重复读 覆盖更新 幻读 未提交读 N Y Y Y Y 已提交读 N N Y Y Y 可重复读 N N N N Y 串行化(顺序读) N N N N N 名词解释 未提交读:允许读取未提交数据,如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。 已提交读:当一个事务开始了,则只有等这个事务提交结束了,才允许其他事务读, 可重复读: 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务 串行化读:按照顺序,一个事务一个事务的执行. 丢失更新:撤销一个事务时，把其他事务已提交的更新数据覆盖（A和B事务并发执行，A事务执行更新后，提交；B事务在A事务更新后，B事务结束前也做了对该行数据的更新操作，然后回滚，则两次更新操作都丢失了）。 脏读:一个事务读到另一个事务未提交的更新数据（事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的）。 不可重复读:一个事务读到另一个事务已提交的更新数据（一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果）。 覆盖更新:这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据（即A事务更新数据，然后B事务更新该数据，A事务查询发现自己更新的数据变了）。 虚读（幻读）:一个事务读到另一个事务已提交的新插入的数据（A和B事务并发执行，A事务查询数据，B事务插入或者删除数据，A事务再次查询发现结果集中有以前没有的数据或者以前有的数据消失了）。 oracle 支持Read Committed和 Serializable和oracle特有的Read-only 这三种事务隔离级别,默认Read Committed mysql支持Read Uncommitted, Read Committed, Repeatable Read,Serializable, 默认Repeatable Read]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象拷贝类PropertyUtils，BeanUtils，BeanCopier]]></title>
      <url>%2F2017%2F03%2F27%2F%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%B1%BBPropertyUtils%EF%BC%8CBeanUtils%EF%BC%8CBeanCopier%2F</url>
      <content type="text"><![CDATA[目前流行的较为公用认可的工具类：Apache的两个版本：（反射机制）12org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest, Object orig) Spring版本：（反射机制）1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高）1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 原理简介反射类型：（apache）都使用静态类调用，最终转化虚拟机中两个单例的工具对象。1234public BeanUtilsBean()&#123; this(new ConvertUtilsBean(), new PropertyUtilsBean());&#125; ConvertUtilsBean可以通过ConvertUtils全局自定义注册。1ConvertUtils.register(new DateConvert(), java.util.Date.class); PropertyUtilsBean的copyProperties方法实现了拷贝的算法。1、 动态bean：1orig instanceof DynaBean：Object value = ((DynaBean)orig).get(name); 然后把value复制到动态bean类2、 Map类型：orig instanceof Map：key值逐个拷贝3、 其他普通类：：从beanInfo【每一个对象都有一个缓存的bean信息，包含属性字段等】取出name，然后把sourceClass和targetClass逐个拷贝 Cglib类型：BeanCopier12copier = BeanCopier.create(source.getClass(), target.getClass(), false);copier.copy(source, target, null); Create对象过程：产生sourceClass-》TargetClass的拷贝代理类，放入jvm中，所以创建的代理类的时候比较耗时。最好保证这个对象的单例模式，可以参照最后一部分的优化方案。创建过程：源代码见1jdk：net.sf.cglib.beans.BeanCopier.Generator.generateClass(ClassVisitor) 1、 获取sourceClass的所有public get 方法-》PropertyDescriptor[] getters2、 获取TargetClass 的所有 public set 方法-》PropertyDescriptor[] setters3、 遍历setters的每一个属性，执行4和54、 按setters的name生成sourceClass的所有setter方法-》PropertyDescriptor getter【不符合javabean规范的类将会可能出现空指针异常】5、 PropertyDescriptor[] setters-》PropertyDescriptor setter6、 将setter和getter名字和类型 配对，生成代理类的拷贝方法。Copy属性过程：调用生成的代理类，代理类的代码和手工操作的代码很类似，效率非常高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[grunt安装和使用]]></title>
      <url>%2F2017%2F03%2F27%2Fgrunt%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装gruntGrunt运行离不开NodeJS和NPM。因此要使用Grunt首要的条件，你的系统需要安装NodeJS和NPM。 安装NodeJS node安装的方法很多，如果是wiondow系统,可以直接进入Nodejs官网中下载各系统所需要的安装包进行安装。 安装NPM 装好NodeJS后，可以在你的终端执行下面的命令安装NPM: curl http://npmjs.org/install.sh | sh 如果这样安装失败，或许你要在上面的命令之前加上sudo，并按提示输入你的用户密码。 如果需要检验安装NodeJS或NPM是否要成功，可以通过下面的命令来检验： $ node -v v0.10.13 $ npm -v 1.3.2 这样你的NodeJS和NPM表示安装成功。 安装CLI 为了方便使用Grunt，你应该在全局范围内安装Grunt的命令行接口(CLI)。在命令行中执行： $ npm install -g grunt-cli 这条命令将会把grunt命令植入到你的系统路径中，这样就允许你从任意目录中运行Grunt(定位到任意目录运行grunt命令) 运行grunt 进入到Gruntfile.js的目录,在命令行执行： $ npm install 等待命令执行后，再执行: $ grunt 即可把要压缩处理的文件处理到Gruntfile.js配置的目录 前端开发同学在开发过程中不需要每次都运行上面的grunt命令，可以在命令行运行一个： $ grunt dev 即可时时监听修改过的文件。 不能运行npm install时,运行下面的命令…1.通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 2.命令行指定 npm –registry https://registry.npm.taobao.org info underscore 3.编辑~/.npmrc加入下面内容 registry = https://registry.npm.taobao.org npm可能是默认的proxy http://127.0.0.1.8087 $ npm config set proxy null 把代理去掉就行了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse远程debug]]></title>
      <url>%2F2017%2F03%2F27%2Feclipse%E8%BF%9C%E7%A8%8Bdebug%2F</url>
      <content type="text"><![CDATA[远程Debug(Jboss-eap-6.2为例): 服务器: ..\bin\standalone.conf #JAVA_OPTS=”$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n” 打开注释 eclipse: 右键项目-&gt;debug as-&gt;debug configuration-&gt;remote java application host:服务器IP port:8787(可以自己改跟address=xxxx,一样) 注意, 同时只能一个用户远程debug.否则会报错. 远程服务器部署的代码跟本地要一样.]]></content>
    </entry>

    
  
  
</search>
