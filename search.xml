<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[java内存溢出总结]]></title>
      <url>%2F2017%2F03%2F27%2Fjava%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[首先我们来说说java虚拟机的构成吧: 他是由程序计数器,堆,java虚拟机栈,本地方法栈,方法区这几块构成的, 堆是用来存放对象和数组的,这里我们就可以设计一个无限创造对象来模拟堆溢出. 1234567891011121314151617181920212223/** * 堆溢出 * Exception in thread "main" java.lang.OutOfMemoryError: Java heap space * @author chenwulou */public class HeapLeak &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); while (true) &#123; list.add(new HeapLeak.method()); &#125; &#125; static class method &#123; &#125;&#125; 栈是用来存放基本数据类型，对象引用，方法等等这些东西的,这里我们就能用无限递归来模拟栈溢出 12345678910111213141516171819202122232425/** * 栈溢出 * Exception in thread "main" java.lang.StackOverflowError * @author chenwulou */public class StackLeak &#123; public static void main(String[] args) &#123; method(); &#125; public static void method() &#123; method(); &#125;&#125; 方法区用来存放每个class的结构,比如说运行时常量池、域、方法数据、方法体、构造函数、包括类中的专用方法、实例初始化、接口初始化。cglib可以直接操作字节码，也可以动态产生Class，下面通过cglib来演示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * 方法区溢出 * Exception in thread "main" java.lang.NoClassDefFoundError * @author chenwulou */public class MethodAreaLeak &#123;public static void main(String[] args) &#123;while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create();&#125;&#125;class OOMObject &#123;&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring事务的隔离级别和传播属性]]></title>
      <url>%2F2017%2F03%2F27%2Fspring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[前言对于事务的理解,在日常的开发过程中,相对来说还是比较重要的.不同的业务功能,所需要的事务传播属性以及隔离级别都是不一样的,当然,大多数情况下,我们使用默认的配置就行了,但是,某些特殊情境,我们就需要特殊配置.这里我就大概来说一说事务. 事务的传播属性: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*** Support a current transaction, create a new one if none exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;This is the default setting of a transaction annotation.*/// 支持当前事务,如果没有,创建一个新事务.(默认属性,也是最常用的)REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),/*** Support a current transaction, execute non-transactionally if none exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: For transaction managers with transaction synchronization,* PROPAGATION_SUPPORTS is slightly different from no transaction at all,* as it defines a transaction scope that synchronization will apply for.* As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)* will be shared for the entire specified scope. Note that this depends on* the actual synchronization configuration of the transaction manager.* @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization*///支持当前事务,如果没有事务,就以非事务状态执行SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),/*** Support a current transaction, throw an exception if none exists.* Analogous to EJB transaction attribute of the same name.*///支持当前事务,如果没有事务,抛出异常MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),/*** Create a new transaction, suspend the current transaction if one exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: Actual transaction suspension will not work on out-of-the-box* on all transaction managers. This in particular applies to JtaTransactionManager,* which requires the &#123;@code javax.transaction.TransactionManager&#125; to be* made available it to it (which is server-specific in standard J2EE).* @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager*///新建事务,若当前存在事务,则挂起当前事务REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),/*** Execute non-transactionally, suspend the current transaction if one exists.* Analogous to EJB transaction attribute of the same name.* &lt;p&gt;Note: Actual transaction suspension will not work on out-of-the-box* on all transaction managers. This in particular applies to JtaTransactionManager,* which requires the &#123;@code javax.transaction.TransactionManager&#125; to be* made available it to it (which is server-specific in standard J2EE).* @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager*///以非事务方式执行.若当前存在事务,则挂起当前事务NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),/*** Execute non-transactionally, throw an exception if a transaction exists.* Analogous to EJB transaction attribute of the same name.*///以非事务方式执行.若当前存在事务,则跑出异常NEVER(TransactionDefinition.PROPAGATION_NEVER),/*** Execute within a nested transaction if a current transaction exists,* behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB.* &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific* transaction managers. Out of the box, this only applies to the JDBC* DataSourceTransactionManager when working on a JDBC 3.0 driver.* Some JTA providers might support nested transactions as well.* @see org.springframework.jdbc.datasource.DataSourceTransactionManager*///执行嵌套事务,如果当前存在事务NESTED(TransactionDefinition.PROPAGATION_NESTED); 事务的隔离级别: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/*** Use the default isolation level of the underlying datastore.* All other levels correspond to the JDBC isolation levels.* @see java.sql.Connection*///使用数据库默认的隔离级别DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),/*** A constant indicating that dirty reads, non-repeatable reads and phantom reads* can occur. This level allows a row changed by one transaction to be read by* another transaction before any changes in that row have been committed* (a "dirty read"). If any of the changes are rolled back, the second* transaction will have retrieved an invalid row.* @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED*///读取未提交数据(级别最低,允许事务读取另一个事务未提交的数据)READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),/*** A constant indicating that dirty reads are prevented; non-repeatable reads* and phantom reads can occur. This level only prohibits a transaction* from reading a row with uncommitted changes in it.* @see java.sql.Connection#TRANSACTION_READ_COMMITTED*///读取提交数据(允许事务读取另一个事务提交的数据)READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),/*** A constant indicating that dirty reads and non-repeatable reads are* prevented; phantom reads can occur. This level prohibits a transaction* from reading a row with uncommitted changes in it, and it also prohibits* the situation where one transaction reads a row, a second transaction* alters the row, and the first transaction rereads the row, getting* different values the second time (a "non-repeatable read").* @see java.sql.Connection#TRANSACTION_REPEATABLE_READ*///可重复读REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),/*** A constant indicating that dirty reads, non-repeatable reads and phantom* reads are prevented. This level includes the prohibitions in* &#123;@code ISOLATION_REPEATABLE_READ&#125; and further prohibits the situation* where one transaction reads all rows that satisfy a &#123;@code WHERE&#125;* condition, a second transaction inserts a row that satisfies that* &#123;@code WHERE&#125; condition, and the first transaction rereads for the* same condition, retrieving the additional "phantom" row in the second read.* @see java.sql.Connection#TRANSACTION_SERIALIZABLE*///顺序执行读取(级别最高,最可靠)SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE); 下面整理一张表. 丢失更新 脏读 非重复读 覆盖更新 幻读 未提交读 N Y Y Y Y 已提交读 N N Y Y Y 可重复读 N N N N Y 串行化(顺序读) N N N N N 名词解释 未提交读:允许读取未提交数据,如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。 已提交读:当一个事务开始了,则只有等这个事务提交结束了,才允许其他事务读, 可重复读: 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务 串行化读:按照顺序,一个事务一个事务的执行. 丢失更新:撤销一个事务时，把其他事务已提交的更新数据覆盖（A和B事务并发执行，A事务执行更新后，提交；B事务在A事务更新后，B事务结束前也做了对该行数据的更新操作，然后回滚，则两次更新操作都丢失了）。 脏读:一个事务读到另一个事务未提交的更新数据（事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的）。 不可重复读:一个事务读到另一个事务已提交的更新数据（一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果）。 覆盖更新:这是不可重复读中的特例，一个事务覆盖另一个事务已提交的更新数据（即A事务更新数据，然后B事务更新该数据，A事务查询发现自己更新的数据变了）。 虚读（幻读）:一个事务读到另一个事务已提交的新插入的数据（A和B事务并发执行，A事务查询数据，B事务插入或者删除数据，A事务再次查询发现结果集中有以前没有的数据或者以前有的数据消失了）。 oracle 支持Read Committed和 Serializable和oracle特有的Read-only 这三种事务隔离级别,默认Read Committed mysql支持Read Uncommitted, Read Committed, Repeatable Read,Serializable, 默认Repeatable Read]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对象拷贝类PropertyUtils，BeanUtils，BeanCopier]]></title>
      <url>%2F2017%2F03%2F27%2F%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%B1%BBPropertyUtils%EF%BC%8CBeanUtils%EF%BC%8CBeanCopier%2F</url>
      <content type="text"><![CDATA[目前流行的较为公用认可的工具类：Apache的两个版本：（反射机制）12org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils.copyProperties(Object dest, Object orig) Spring版本：（反射机制）1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高）1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 原理简介反射类型：（apache）都使用静态类调用，最终转化虚拟机中两个单例的工具对象。1234public BeanUtilsBean()&#123; this(new ConvertUtilsBean(), new PropertyUtilsBean());&#125; ConvertUtilsBean可以通过ConvertUtils全局自定义注册。1ConvertUtils.register(new DateConvert(), java.util.Date.class); PropertyUtilsBean的copyProperties方法实现了拷贝的算法。1、 动态bean：1orig instanceof DynaBean：Object value = ((DynaBean)orig).get(name); 然后把value复制到动态bean类2、 Map类型：orig instanceof Map：key值逐个拷贝3、 其他普通类：：从beanInfo【每一个对象都有一个缓存的bean信息，包含属性字段等】取出name，然后把sourceClass和targetClass逐个拷贝 Cglib类型：BeanCopier12copier = BeanCopier.create(source.getClass(), target.getClass(), false);copier.copy(source, target, null); Create对象过程：产生sourceClass-》TargetClass的拷贝代理类，放入jvm中，所以创建的代理类的时候比较耗时。最好保证这个对象的单例模式，可以参照最后一部分的优化方案。创建过程：源代码见1jdk：net.sf.cglib.beans.BeanCopier.Generator.generateClass(ClassVisitor) 1、 获取sourceClass的所有public get 方法-》PropertyDescriptor[] getters2、 获取TargetClass 的所有 public set 方法-》PropertyDescriptor[] setters3、 遍历setters的每一个属性，执行4和54、 按setters的name生成sourceClass的所有setter方法-》PropertyDescriptor getter【不符合javabean规范的类将会可能出现空指针异常】5、 PropertyDescriptor[] setters-》PropertyDescriptor setter6、 将setter和getter名字和类型 配对，生成代理类的拷贝方法。Copy属性过程：调用生成的代理类，代理类的代码和手工操作的代码很类似，效率非常高。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[grunt安装和使用]]></title>
      <url>%2F2017%2F03%2F27%2Fgrunt%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[安装gruntGrunt运行离不开NodeJS和NPM。因此要使用Grunt首要的条件，你的系统需要安装NodeJS和NPM。 安装NodeJS node安装的方法很多，如果是wiondow系统,可以直接进入Nodejs官网中下载各系统所需要的安装包进行安装。 安装NPM 装好NodeJS后，可以在你的终端执行下面的命令安装NPM: curl http://npmjs.org/install.sh | sh 如果这样安装失败，或许你要在上面的命令之前加上sudo，并按提示输入你的用户密码。 如果需要检验安装NodeJS或NPM是否要成功，可以通过下面的命令来检验： $ node -v v0.10.13 $ npm -v 1.3.2 这样你的NodeJS和NPM表示安装成功。 安装CLI 为了方便使用Grunt，你应该在全局范围内安装Grunt的命令行接口(CLI)。在命令行中执行： $ npm install -g grunt-cli 这条命令将会把grunt命令植入到你的系统路径中，这样就允许你从任意目录中运行Grunt(定位到任意目录运行grunt命令) 运行grunt 进入到Gruntfile.js的目录,在命令行执行： $ npm install 等待命令执行后，再执行: $ grunt 即可把要压缩处理的文件处理到Gruntfile.js配置的目录 前端开发同学在开发过程中不需要每次都运行上面的grunt命令，可以在命令行运行一个： $ grunt dev 即可时时监听修改过的文件。 不能运行npm install时,运行下面的命令…1.通过config命令 npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response） 2.命令行指定 npm –registry https://registry.npm.taobao.org info underscore 3.编辑~/.npmrc加入下面内容 registry = https://registry.npm.taobao.org npm可能是默认的proxy http://127.0.0.1.8087 $ npm config set proxy null 把代理去掉就行了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse远程debug]]></title>
      <url>%2F2017%2F03%2F27%2Feclipse%E8%BF%9C%E7%A8%8Bdebug%2F</url>
      <content type="text"><![CDATA[远程Debug(Jboss-eap-6.2为例): 服务器: ..\bin\standalone.conf #JAVA_OPTS=”$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,address=8787,server=y,suspend=n” 打开注释 eclipse: 右键项目-&gt;debug as-&gt;debug configuration-&gt;remote java application host:服务器IP port:8787(可以自己改跟address=xxxx,一样) 注意, 同时只能一个用户远程debug.否则会报错. 远程服务器部署的代码跟本地要一样.]]></content>
    </entry>

    
  
  
</search>
